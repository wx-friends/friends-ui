# 碰碰小程序接口优化记录

## 文档信息
- **创建时间**：2025-12-07
- **最后更新**：2025-12-08（新增我喜欢谁接口、动态距离计算、位置管理接口）
- **作者**：后端开发团队
- **说明**：记录接口变更、优化和Bug修复，供前端对接参考
- **Base URL**：`http://localhost:8080`

---

## 📋 优化目录

- [2025-12-06 接口优化](#2025-12-06-接口优化)
  - [修复：发布活动接口时间格式问题](#1-修复发布活动接口时间格式问题)
  - [优化：推荐用户接口返回数据增强](#2-优化推荐用户接口返回数据增强)
  - [新增：用户卡片统计数据字段](#3-新增用户卡片统计数据字段)

- [2025-12-07 接口优化](#2025-12-07-接口优化)
  - [重构：评论系统支持多级树形结构](#4-重构评论系统支持多级树形结构)
  - [新增：搭子匹配模式和设置字段](#5-新增搭子匹配模式和设置字段)
  - [增强：用户资料接口返回数据](#6-增强用户资料接口返回数据)

- [2025-12-08 接口优化](#2025-12-08-接口优化)
  - [新增：取消喜欢接口](#7-新增取消喜欢接口)
  - [新增：移除粉丝接口](#8-新增移除粉丝接口)
  - [新增：编辑动态接口](#9-新增编辑动态接口)
  - [新增：查看我喜欢谁接口](#10-新增查看我喜欢谁接口)
  - [优化：动态列表接口支持距离计算](#11-优化动态列表接口支持距离计算)
  - [新增：快速更新位置接口](#12-新增快速更新位置接口)
  - [新增：快速获取位置接口](#13-新增快速获取位置接口)

---

## 2025-12-06 接口优化

### 1. 修复：发布活动接口时间格式问题

#### 🔧 问题描述
发布活动时，后端无法正确解析前端传递的时间格式，导致 400 错误。

#### 📌 涉及接口
**POST** `/api/moments/publish`

#### ⚠️ 问题表现
请求时返回错误：
```json
{
  "code": 400,
  "message": "时间格式错误"
}
```

#### ✅ 解决方案
后端已修复，现在支持前端常用的时间格式。

#### 📥 请求参数（仅活动类型需要）

**修复前：** ❌ 不支持空格分隔的时间格式  
**修复后：** ✅ 支持以下格式

```json
{
  "momentType": 3,
  "activityTime": "2025-12-06 00:00:00",  // ✅ 推荐：空格分隔
  "title": "周末爬山活动",
  "content": "约几个朋友一起爬山",
  // ... 其他字段
}
```

**时间格式说明：**
- ✅ 支持格式：`"2025-12-06 00:00:00"`（空格分隔）
- ✅ 也支持：`"2025-12-06T00:00:00"`（ISO-8601）

#### 🎯 前端注意事项
- 使用常规的 `YYYY-MM-DD HH:mm:ss` 格式即可
- 无需转换为ISO格式
- 仅在 `momentType=3`（活动）或 `momentType=4`（官方活动）时需要传递此字段

---

### 2. 优化：推荐用户接口返回数据增强

#### 🎯 优化目标
解决用户偏好设置严格时找不到匹配对象的问题，提供更智能的推荐策略。

#### 📌 涉及接口
**GET** `/api/matching/recommend`

#### 📤 返回数据新增字段

在每个用户卡片对象中新增 `matchLevel` 字段，表示匹配质量等级：

```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "userId": "U1699123456789AB12CD",
        "nickname": "小明",
        "matchLevel": 1,  // ✨ 新增字段
        // ... 其他字段
      }
    ],
    "total": 50
  }
}
```

#### 📊 matchLevel 字段说明

| matchLevel 值 | 匹配质量 | 说明 | 前端建议展示 |
|--------------|---------|------|-------------|
| `1` | 严格匹配 | 完全符合用户设置的所有偏好 | ⭐⭐⭐ "完全匹配" |
| `2` | 标准匹配 | 大部分条件符合，略微放宽 | ⭐⭐ "高度匹配" |
| `3` | 宽松匹配 | 核心条件符合（性别、大致年龄） | ⭐ "推荐给你" |
| `4` | 兜底推荐 | 保证有推荐结果 | "附近的人" |

#### 🎨 前端展示建议

**推荐列表页面：**
```javascript
// 根据 matchLevel 显示不同标识
const getLevelTag = (level) => {
  switch(level) {
    case 1: return { text: '完全匹配', icon: '⭐⭐⭐', color: '#FF6B6B' };
    case 2: return { text: '高度匹配', icon: '⭐⭐', color: '#4ECDC4' };
    case 3: return { text: '推荐给你', icon: '⭐', color: '#95E1D3' };
    case 4: return { text: '附近的人', icon: '', color: '#999' };
  }
}
```

**效果展示：**
```
┌─────────────────────────┐
│ 小明，25岁              │
│ ⭐⭐⭐ 完全匹配         │ ← matchLevel = 1
│ 匹配度 85.5分           │
│ 距离 1.2km              │
└─────────────────────────┘
```

#### 💡 业务逻辑说明

后端会按以下优先级推荐：
1. 优先返回 `matchLevel=1` 的用户（完全符合偏好）
2. 如果数量不足，自动放宽到 `matchLevel=2`
3. 依次降级，保证总能返回推荐结果

#### ✨ 优化效果
- ✅ 解决了"找不到匹配对象"的问题
- ✅ 优先推荐最匹配的用户
- ✅ 用户可以看到匹配质量
- ✅ 提升用户体验和匹配成功率

---

### 3. 新增：用户卡片统计数据字段

#### 🎯 优化目标
让用户在浏览推荐列表时能看到对方的社交活跃度，辅助决策。

#### 📌 涉及接口
以下所有返回用户卡片的接口都已新增统计数据：

| 接口 | 说明 |
|------|------|
| `GET /api/matching/recommend` | 获取推荐用户列表 |
| `GET /api/matching/liked-me` | 查看谁喜欢我 |
| `GET /api/matching/history` | 获取匹配历史 |
| `GET /api/follow/following` | 获取关注列表 |
| `GET /api/follow/followers` | 获取粉丝列表 |
| `GET /api/favorite/users` | 获取收藏用户列表 |

#### 📤 返回数据新增字段

在用户卡片对象中新增 4 个社交统计字段：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `followingCount` | Integer | 该用户关注了多少人 | `128` |
| `followersCount` | Integer | 该用户有多少粉丝 | `256` |
| `buddyMatchCount` | Integer | 搭子匹配成功数量 | `12` |
| `activityJoinCount` | Integer | 参与的活动数量 | `18` |

#### 📋 完整返回示例
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "userId": "U1699123456789AB12CD",
        "nickname": "小明",
        "avatar": "https://example.com/avatar.jpg",
        "age": 25,
        "gender": 1,
        "matchScore": 85.5,
        "matchLevel": 1,
        
        // ✨ 新增的社交统计数据
        "followingCount": 128,      // 关注数
        "followersCount": 256,      // 粉丝数
        "buddyMatchCount": 12,      // 搭子匹配数
        "activityJoinCount": 18,    // 活动参与数
        
        // 其他字段...
        "distance": 1500,
        "distanceText": "1.5km",
        "bio": "热爱生活，喜欢旅行",
        "interestTags": ["旅行", "阅读", "健身"]
      }
    ],
    "total": 50,
    "size": 10,
    "current": 1
  }
}
```

#### 🎨 前端展示建议

**用户卡片页面：**
```
┌─────────────────────────────────┐
│ 小明，25岁                       │
│ ⭐⭐⭐ 完全匹配                  │
│ 距离 1.5km · 匹配度 85.5分       │
│                                  │
│ 📊 社交活跃度                    │
│ ├─ 🔥 粉丝 256 · 关注 128       │
│ ├─ 💑 搭子匹配 12个              │
│ └─ 🎯 参与活动 18场              │
│                                  │
│ 🏷️ 旅行 · 阅读 · 健身          │
└─────────────────────────────────┘
```

**代码示例：**
```javascript
// 展示社交统计
const UserStats = ({ user }) => (
  <View className="stats">
    <Text>👥 粉丝 {user.followersCount}</Text>
    <Text>💑 匹配 {user.buddyMatchCount}个</Text>
    <Text>🎯 活动 {user.activityJoinCount}场</Text>
  </View>
);
```

#### 🎯 前端注意事项
- 统计数据都是实时查询，可能为 `0`
- 建议在列表页简化展示，详情页完整展示
- 可根据数值高低显示不同颜色或样式

#### ✨ 优化效果
- ✅ 用户卡片信息更丰富完整
- ✅ 可以判断对方社交活跃度
- ✅ 辅助用户做出更好的匹配决策
- ✅ 提升用户体验和信任度

---

## 2025-12-07 接口优化

### 4. 重构：评论系统支持多级树形结构

#### 🎯 优化目标
解决评论系统无法正确展示多级回复的问题，实现类似微博/朋友圈的评论树形结构。

#### ❌ 原有问题
1. **扁平化查询，无层级关系**
   - 所有评论混在一起按时间排序
   - 无法区分一级评论和回复
   
2. **缺少根评论引用**
   - A 评论动态 → B 回复 A → C 回复 B
   - C 的 `replyToCommentId` 指向 B，但不知道根评论是 A
   - 无法将所有回复归类到同一个一级评论下

3. **前端展示混乱**
   - 无法构建评论楼层
   - 回复关系不清晰

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `GET /api/comments/{momentId}` | 获取评论列表 |
| `POST /api/comments/{momentId}` | 发表评论 |
| `POST /api/comments/{momentId}/{commentId}/reply` | 回复评论 |

#### 📤 返回数据结构变化

**新增字段：**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `parentId` | Long | 父评论ID（一级评论为null） | `123` |
| `rootId` | Long | 根评论ID（一级评论指向自己） | `100` |
| `replyCount` | Integer | 回复数量（仅一级评论） | `5` |
| `replies` | List<CommentDTO> | 子评论列表（仅一级评论） | `[...]` |

**废弃字段：**
- `replyToCommentId` - 保留用于兼容，建议使用 `parentId` 替代

#### 📋 完整返回示例

**优化前（扁平结构）：** ❌
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "id": 1,
        "content": "这个活动很棒！",
        "replyToCommentId": null
      },
      {
        "id": 2,
        "content": "同意，我也想参加",
        "replyToCommentId": 1
      },
      {
        "id": 3,
        "content": "那我们一起吧",
        "replyToCommentId": 2
      }
    ]
  }
}
```
**问题：** 无法区分层级，前端需要自己组装树形结构

---

**优化后（树形结构）：** ✅
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "id": 1,
        "content": "这个活动很棒！",
        "parentId": null,
        "rootId": 1,
        "replyCount": 2,
        "replies": [
          {
            "id": 2,
            "content": "同意，我也想参加",
            "parentId": 1,
            "rootId": 1,
            "replyToUserId": "U123",
            "replyToNickname": "小明"
          },
          {
            "id": 3,
            "content": "那我们一起吧",
            "parentId": 2,
            "rootId": 1,
            "replyToUserId": "U456",
            "replyToNickname": "小红"
          }
        ]
      }
    ]
  }
}
```

#### 🎨 前端展示建议

**评论列表页面：**
```html
<!-- 一级评论 -->
<div class="comment-root">
  <div class="comment-content">这个活动很棒！</div>
  <div class="reply-count">共 2 条回复 ▼</div>
  
  <!-- 二级回复列表 -->
  <div class="replies">
    <div class="reply-item">
      <span class="reply-to">回复 @小明：</span>
      <span>同意，我也想参加</span>
    </div>
    <div class="reply-item">
      <span class="reply-to">回复 @小红：</span>
      <span>那我们一起吧</span>
    </div>
  </div>
</div>
```

**代码示例：**
```javascript
// 渲染评论树
const CommentTree = ({ comment }) => (
  <View className="comment-item">
    {/* 一级评论 */}
    <View className="comment-content">
      <Text>{comment.content}</Text>
    </View>
    
    {/* 回复列表 */}
    {comment.replies && comment.replies.length > 0 && (
      <View className="replies">
        <Text className="reply-count">
          共 {comment.replyCount} 条回复
        </Text>
        {comment.replies.map(reply => (
          <View key={reply.id} className="reply-item">
            {reply.replyToNickname && (
              <Text className="reply-to">
                回复 @{reply.replyToNickname}：
              </Text>
            )}
            <Text>{reply.content}</Text>
          </View>
        ))}
      </View>
    )}
  </View>
);
```

#### 🎯 前端注意事项

1. **分页逻辑变化**
   - 分页只对一级评论生效
   - 每个一级评论的所有回复会全部加载

2. **回复层级**
   - 一级评论：`parentId = null`, `rootId = id`
   - 二级回复：`parentId = 一级评论ID`, `rootId = 一级评论ID`
   - 三级回复：`parentId = 二级回复ID`, `rootId = 一级评论ID`

3. **兼容性**
   - `replyToCommentId` 字段已废弃但保留
   - 建议使用 `parentId` 和 `rootId`

#### 🔄 数据库变更

**新增字段：**
```sql
-- parent_id: 父评论ID
ALTER TABLE t_moment_comment ADD COLUMN parent_id BIGINT;

-- root_id: 根评论ID  
ALTER TABLE t_moment_comment ADD COLUMN root_id BIGINT;

-- 索引
ALTER TABLE t_moment_comment ADD INDEX idx_parent_id (parent_id);
ALTER TABLE t_moment_comment ADD INDEX idx_root_id (root_id);
```

**数据迁移：** 已自动迁移旧数据

#### ✨ 优化效果
- ✅ 评论支持多级树形结构
- ✅ 前端无需自己组装树形数据
- ✅ 一级评论分页，回复全部加载
- ✅ 回复关系更清晰直观
- ✅ 提升用户体验

#### ⚠️ 注意事项
- 运行前需要执行数据库迁移脚本
- 旧字段 `replyToCommentId` 保留兼容，新功能请使用 `parentId`

---

### 5. 新增：搭子匹配模式和设置字段

#### 🎯 优化目标
补充搭子匹配的专属设置字段，区分"恋爱交友"和"搭子匹配"两种不同的匹配模式。

#### ❌ 原有问题
1. **只有恋爱交友设置**
   - 只有年龄、身高、学历、收入等传统交友字段
   - 缺少搭子匹配的核心设置

2. **无法区分匹配模式**
   - 没有 `matchMode` 字段区分两种模式
   - 无法针对不同模式返回不同推荐策略

3. **缺少搭子核心字段**
   - 搭子类型（运动、旅行、美食等）
   - 活动时间偏好（工作日、周末、早晚）
   - 距离范围（5km、10km、20km、50km）

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `POST /api/matching/preference` | 设置匹配偏好 |
| `GET /api/matching/preference` | 获取匹配偏好 |
| `GET /api/matching/recommend` | 获取推荐用户列表 |

#### 📤 新增字段说明

**通用字段：**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `matchMode` | Integer | 匹配模式：1-恋爱交友，2-搭子匹配 | `2` |

**搭子匹配专用字段：**

| 字段名 | 类型 | 说明 | 可选值 | 示例 |
|--------|------|------|--------|------|
| `buddyTypes` | String | 搭子类型（多选） | 运动,学习,旅行,健身,爱好,美食,电影,音乐 | `"运动,旅行,美食"` |
| `activityTimes` | String | 活动时间（多选） | 工作日,周末,早上,下午,晚上 | `"周末,晚上"` |
| `distanceRange` | Integer | 距离范围(km) | 5, 10, 20, 50 | `20` |

#### 📋 请求示例

**恋爱交友模式：**
```json
{
  "matchMode": 1,
  "minAge": 25,
  "maxAge": 35,
  "minHeight": 165,
  "maxHeight": 180,
  "education": "本科,硕士",
  "incomeRange": "10-20万",
  "maxDistance": 10,
  "locationLatitude": 39.908823,
  "locationLongitude": 116.397470
}
```

**搭子匹配模式：**
```json
{
  "matchMode": 2,
  "buddyTypes": "运动,旅行,美食",
  "activityTimes": "周末,晚上",
  "distanceRange": 20,
  "locationLatitude": 39.908823,
  "locationLongitude": 116.397470
}
```

#### 📤 返回示例

```json
{
  "code": 200,
  "data": {
    "userId": "U1699123456789AB12CD",
    "matchMode": 2,
    
    // 搭子匹配设置
    "buddyTypes": "运动,旅行,美食",
    "activityTimes": "周末,晚上",
    "distanceRange": 20,
    
    // 位置信息（通用）
    "locationLatitude": 39.908823,
    "locationLongitude": 116.397470,
    
    // 恋爱交友设置（matchMode=1时返回）
    "minAge": null,
    "maxAge": null,
    "education": null
    // ...
  }
}
```

#### 🎨 前端展示建议

**搭子类型选择：**
```html
<view class="buddy-types">
  <view class="section-title">搭子类型</view>
  <view class="tags">
    <tag class="运动" />
    <tag class="学习" />
    <tag class="旅行" />
    <tag class="健身" />
    <tag class="爱好" />
    <tag class="美食" />
    <tag class="电影" />
    <tag class="音乐" />
  </view>
</view>
```

**活动时间选择：**
```html
<view class="activity-times">
  <view class="section-title">活动时间偏好</view>
  <view class="tags">
    <tag class="工作日" />
    <tag class="周末" />
    <tag class="早上" />
    <tag class="下午" />
    <tag class="晚上" />
  </view>
</view>
```

**距离范围选择：**
```html
<view class="distance-range">
  <view class="section-title">距离范围</view>
  <view class="options">
    <radio value="5">5km内</radio>
    <radio value="10">10km内</radio>
    <radio value="20">20km内</radio>
    <radio value="50">50km内</radio>
  </view>
</view>
```

#### 🎯 前端注意事项

1. **字段联动**
   - `matchMode = 1` 时，显示恋爱交友设置（年龄、身高等）
   - `matchMode = 2` 时，显示搭子匹配设置（类型、时间等）

2. **多选字段格式**
   - `buddyTypes` 和 `activityTimes` 用逗号分隔
   - 前端提交时拼接，展示时split

3. **距离字段区分**
   - 恋爱交友用 `maxDistance`
   - 搭子匹配用 `distanceRange`

#### 🔄 数据库变更

**新增字段：**
```sql
-- 匹配模式
ALTER TABLE t_matching_preference ADD COLUMN match_mode TINYINT DEFAULT 1;

-- 搭子类型偏好
ALTER TABLE t_matching_preference ADD COLUMN buddy_types VARCHAR(200);

-- 活动时间偏好
ALTER TABLE t_matching_preference ADD COLUMN activity_times VARCHAR(100);

-- 距离范围
ALTER TABLE t_matching_preference ADD COLUMN distance_range INT;
```

#### ✨ 优化效果
- ✅ 支持两种匹配模式切换
- ✅ 搭子匹配有专属设置字段
- ✅ 更符合搭子社交的产品定位
- ✅ 推荐算法可以针对不同模式优化

#### ⚠️ 注意事项
- 运行前需要执行数据库迁移脚本 `V1.2__add_buddy_matching_fields.sql`
- 默认 `matchMode = 1`（恋爱交友），需用户手动切换

---

### 6. 增强：用户资料接口返回数据

#### 🎯 优化目标
补充用户资料页的关键展示信息，包括相册预览、交互状态、最近动态和参与的活动。

#### ❌ 原有问题
1. **缺少相册预览**
   - 用户资料页无法直接看到照片
   - 需要额外调用相册接口

2. **缺少交互状态**
   - 不知道是否已关注该用户
   - 不知道是否已喜欢该用户

3. **缺少内容展示**
   - 看不到对方最近的动态
   - 看不到对方参与的活动

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `GET /api/profile/{userId}` | 查看他人资料 |
| `GET /api/profile/my` | 查看我的资料 |

#### 📤 新增字段说明

**1. 相册照片预览**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `photoAlbum` | List<String> | 相册照片（最多3张） | `["https://...jpg"]` |

**2. 交互状态**

| 字段名 | 类型 | 说明 | 值 |
|--------|------|------|-----|
| `isFollowing` | Integer | 是否关注了他 | 0-否，1-是 |
| `isLiked` | Integer | 是否喜欢了他 | 0-否，1-是 |

**3. 最近动态（recentMoments）**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | Long | 动态ID | `123` |
| `momentType` | Integer | 动态类型 | `1` |
| `content` | String | 内容 | `"今天天气不错"` |
| `coverImage` | String | 封面图 | `"https://...jpg"` |
| `likeCount` | Integer | 点赞数 | `10` |
| `commentCount` | Integer | 评论数 | `5` |
| `createdAt` | LocalDateTime | 创建时间 | `"2025-12-06T10:30:00"` |

**4. 参与的活动（participatedActivities）**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | Long | 活动ID | `456` |
| `title` | String | 活动标题 | `"周末爬山活动"` |
| `coverImage` | String | 活动封面 | `"https://...jpg"` |
| `activityTime` | LocalDateTime | 活动时间 | `"2025-12-10T09:00:00"` |
| `registrationCount` | Integer | 报名人数 | `20` |
| `status` | Integer | 活动状态 | `1` |

#### 📋 完整返回示例

```json
{
  "code": 200,
  "data": {
    "userId": "U1699123456789AB12CD",
    "nickname": "张三",
    "avatar": "https://example.com/avatar.jpg",
    "age": 25,
    "gender": 1,
    "bio": "热爱生活，喜欢旅行",
    
    // ✨ 新增：相册预览（最多3张）
    "photoAlbum": [
      "https://example.com/photo1.jpg",
      "https://example.com/photo2.jpg",
      "https://example.com/photo3.jpg"
    ],
    
    // ✨ 新增：交互状态
    "isFollowing": 1,  // 已关注
    "isLiked": 1,      // 已喜欢
    
    // ✨ 新增：最近动态（最多3条）
    "recentMoments": [
      {
        "id": 123,
        "momentType": 1,
        "content": "今天天气不错",
        "coverImage": "https://example.com/moment.jpg",
        "likeCount": 10,
        "commentCount": 5,
        "createdAt": "2025-12-06T10:30:00"
      },
      {
        "id": 124,
        "momentType": 3,
        "content": "周末爬山约起来",
        "coverImage": "https://example.com/moment2.jpg",
        "likeCount": 15,
        "commentCount": 8,
        "createdAt": "2025-12-05T14:20:00"
      }
    ],
    
    // ✨ 新增：参与的活动（最多3个）
    "participatedActivities": [
      {
        "id": 456,
        "title": "周末爬山活动",
        "coverImage": "https://example.com/activity.jpg",
        "activityTime": "2025-12-10T09:00:00",
        "registrationCount": 20,
        "status": 1
      },
      {
        "id": 457,
        "title": "羽毛球友谊赛",
        "coverImage": "https://example.com/activity2.jpg",
        "activityTime": "2025-12-15T15:00:00",
        "registrationCount": 12,
        "status": 1
      }
    ],
    
    // 原有字段
    "tags": ["旅行", "美食", "运动"],
    "vipLevel": 1,
    "onlineStatus": 1,
    "height": 175,
    "occupation": "互联网",
    "education": "本科",
    "city": "北京"
  }
}
```

#### 🎨 前端展示建议

**用户资料页面布局：**
```html
<view class="profile-page">
  <!-- 1. 顶部基本信息 -->
  <view class="profile-header">
    <image class="avatar" :src="avatar" />
    <text class="nickname">{{ nickname }}</text>
    <text class="bio">{{ bio }}</text>
  </view>
  
  <!-- 2. 互动按钮 -->
  <view class="action-buttons">
    <button :class="{active: isFollowing}" @click="toggleFollow">
      <icon type="follow" />
      {{ isFollowing ? '已关注' : '关注TA' }}
    </button>
    <button :class="{active: isLiked}" @click="toggleLike">
      <icon type="heart" />
      {{ isLiked ? '已喜欢' : '喜欢' }}
    </button>
    <button @click="startChat">
      <icon type="chat" />
      聊天
    </button>
  </view>
  
  <!-- 3. 相册预览 -->
  <view class="photo-album-section">
    <view class="section-title">
      TA的相册
      <text class="more" @click="viewFullAlbum">查看更多 ></text>
    </view>
    <view class="photo-grid">
      <image 
        v-for="(photo, index) in photoAlbum" 
        :key="index"
        :src="photo"
        @click="previewPhotos(index)"
      />
      <!-- 如果有更多照片，显示"+N"提示 -->
      <view v-if="hasMorePhotos" class="more-indicator">
        +{{ totalPhotoCount - 3 }}
      </view>
    </view>
  </view>
  
  <!-- 4. 最近动态 -->
  <view class="moments-section">
    <view class="section-title">
      TA的动态
      <text class="more" @click="viewAllMoments">查看全部 ></text>
    </view>
    <view class="moment-list">
      <moment-card 
        v-for="moment in recentMoments" 
        :key="moment.id"
        :data="moment"
        mode="simple"
      />
    </view>
  </view>
  
  <!-- 5. 参与的活动 -->
  <view class="activities-section">
    <view class="section-title">
      TA参与的活动
      <text class="more" @click="viewAllActivities">查看全部 ></text>
    </view>
    <view class="activity-list">
      <activity-card 
        v-for="activity in participatedActivities" 
        :key="activity.id"
        :data="activity"
        mode="compact"
      />
    </view>
  </view>
  
  <!-- 6. 标签和其他信息 -->
  <view class="tags-section">
    <tag v-for="tag in tags" :key="tag">{{ tag }}</tag>
  </view>
</view>
```

**代码示例：**
```javascript
// 用户资料页面
export default {
  data() {
    return {
      profile: null
    }
  },
  
  computed: {
    hasMorePhotos() {
      return this.profile?.photoAlbum?.length >= 3;
    }
  },
  
  methods: {
    // 加载用户资料
    async loadProfile(userId) {
      const res = await api.get(`/profile/${userId}`);
      this.profile = res.data;
    },
    
    // 预览照片
    previewPhotos(index) {
      wx.previewImage({
        current: this.profile.photoAlbum[index],
        urls: this.profile.photoAlbum
      });
    },
    
    // 查看完整相册
    async viewFullAlbum() {
      // 调用完整相册接口
      const res = await api.get('/media/list', {
        params: { mediaType: 'album', userId: this.profile.userId }
      });
      // 展示完整相册
    },
    
    // 切换关注状态
    async toggleFollow() {
      if (this.profile.isFollowing) {
        await api.post(`/follow/unfollow/${this.profile.userId}`);
        this.profile.isFollowing = 0;
      } else {
        await api.post(`/follow/${this.profile.userId}`);
        this.profile.isFollowing = 1;
      }
    },
    
    // 切换喜欢状态
    async toggleLike() {
      if (this.profile.isLiked) {
        // 取消喜欢的逻辑
      } else {
        await api.post(`/matching/like/${this.profile.userId}`);
        this.profile.isLiked = 1;
      }
    }
  }
}
```

#### 🎯 前端注意事项

1. **字段判断**
   - `photoAlbum`、`recentMoments`、`participatedActivities` 可能为空数组
   - 展示前需要判断数组长度

2. **交互状态**
   - 查看自己的资料时，`isFollowing` 和 `isLiked` 都为 0
   - 不应该显示关注和喜欢按钮

3. **数量限制**
   - 相册最多3张，需要"查看更多"按钮
   - 动态最多3条，需要"查看全部"链接
   - 活动最多3个，需要"查看全部"链接

4. **点击事件**
   - 点击动态卡片 → 跳转到动态详情页
   - 点击活动卡片 → 跳转到活动详情页
   - 点击相册照片 → 预览大图

#### ✨ 优化效果
- ✅ 用户资料页信息完整丰富
- ✅ 一次请求获取所有必要信息，减少接口调用
- ✅ 清晰展示交互状态（关注/喜欢）
- ✅ 直观展示用户活跃度（动态/活动）
- ✅ 提升用户体验和信息展示效率

#### ⚠️ 注意事项
- 动态和活动查询已自动过滤（审核通过、未删除）
- 相册照片来自 `t_user_profile.photo_album` 字段
- 活动封面来自 `t_moment_photo` 表的第一张图片

---

## 2025-12-08 接口优化

### 7. 新增：取消喜欢接口

#### 🎯 优化目标
补充取消喜欢功能，允许用户撤销之前的喜欢操作，提升用户体验。

#### ❌ 原有问题
1. **缺少取消喜欢功能**
   - 用户误操作喜欢后无法撤销
   - 在"谁喜欢我"列表中无法移除不感兴趣的用户
   - 已匹配的用户无法取消匹配

2. **业务场景缺失**
   - 用户改变心意想取消喜欢
   - 清理"谁喜欢我"列表中的不感兴趣用户

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `DELETE /api/matching/like` | 取消喜欢操作 |

#### 📥 请求参数

**请求方式：** `DELETE`  
**Content-Type：** `application/json`

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| toUserId | String | 是 | 要取消喜欢的用户业务ID | `"U1735123456789ABCDEF"` |

#### 📋 请求示例

```bash
curl -X DELETE "http://localhost:8080/api/matching/like" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "toUserId": "U1735123456789ABCDEF"
  }'
```

**请求Body：**
```json
{
  "toUserId": "U1735123456789ABCDEF"
}
```

#### 📤 响应示例

```json
{
  "code": 200,
  "message": "取消喜欢成功",
  "data": "取消喜欢成功"
}
```

#### 🔄 业务逻辑说明

1. **取消单向喜欢**
   - 如果只是单向喜欢（对方未回应），直接删除喜欢记录
   - 对方在"谁喜欢我"列表中不再看到你

2. **取消双向匹配**
   - 如果已经匹配成功（双向喜欢），取消后：
     - 删除你的喜欢记录
     - 将对方的记录改为单向喜欢（`matchResult = 1`）
     - 对方仍能看到你，但匹配状态降级为单向

3. **限制说明**
   - 只能取消"喜欢"和"超级喜欢"类型的记录
   - 不能取消"跳过"记录（跳过本身就是拒绝）

#### 🎨 前端展示建议

**用户资料页面：**
```javascript
// 取消喜欢按钮
<button 
  v-if="isLiked" 
  @click="cancelLike"
  class="btn-cancel-like"
>
  取消喜欢
</button>

// 取消喜欢方法
async cancelLike() {
  try {
    await api.delete('/matching/like', {
      data: { toUserId: this.profile.userId }
    });
    this.isLiked = false;
    this.showToast('已取消喜欢');
  } catch (error) {
    this.showToast('取消失败，请重试');
  }
}
```

**"谁喜欢我"列表：**
```javascript
// 在列表中显示"移除"按钮
<UserCard 
  v-for="user in likedMeList"
  :key="user.userId"
  :user="user"
>
  <button @click="removeFromLikedMe(user.userId)">
    移除
  </button>
</UserCard>

// 移除方法（调用取消喜欢接口）
async removeFromLikedMe(userId) {
  // 注意：这里需要调用对方的视角，即对方取消喜欢我
  // 实际业务中可能需要单独的接口，或者通过"取消喜欢"接口实现
  await api.delete('/matching/like', {
    data: { toUserId: userId }
  });
}
```

#### 🎯 前端注意事项

1. **接口调用方向**
   - 取消喜欢：我取消喜欢对方 → `DELETE /api/matching/like`，`toUserId` 是对方
   - 从"谁喜欢我"移除：需要对方取消喜欢我，但当前接口不支持，建议新增接口或调整逻辑

2. **状态更新**
   - 取消喜欢后，需要更新本地状态 `isLiked = false`
   - 如果已匹配，需要更新匹配状态

3. **错误处理**
   - 如果记录不存在，返回 40004 错误
   - 需要提示用户操作失败

#### ✨ 优化效果
- ✅ 用户可以撤销误操作
- ✅ 支持取消已匹配的用户
- ✅ 提升用户体验和操作灵活性
- ✅ 完善匹配功能的闭环

---

### 8. 新增：移除粉丝接口

#### 🎯 优化目标
补充移除粉丝功能，允许用户主动移除不想要的粉丝，保护用户隐私和社交环境。

#### ❌ 原有问题
1. **缺少移除粉丝功能**
   - 用户无法主动移除粉丝
   - 遇到骚扰或不想被关注时无法处理
   - 粉丝列表管理功能不完整

2. **隐私保护缺失**
   - 无法控制谁可以关注我
   - 无法清理粉丝列表

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `DELETE /api/user/followers/{followerId}` | 移除粉丝 |

#### 📥 请求参数

**请求方式：** `DELETE`  
**路径参数：**

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| followerId | String | 是 | 要移除的粉丝用户业务ID | `"U1735123456789ABCDEF"` |

#### 📋 请求示例

```bash
curl -X DELETE "http://localhost:8080/api/user/followers/U1735123456789ABCDEF" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

#### 📤 响应示例

```json
{
  "code": 200,
  "message": "移除粉丝成功",
  "data": "移除粉丝成功"
}
```

#### 🔄 业务逻辑说明

1. **移除操作**
   - 删除对方关注我的记录（`followerId` 关注 `userId`）
   - 使用软删除，记录保留但不再显示

2. **验证逻辑**
   - 验证该用户确实是你的粉丝
   - 不能移除自己
   - 用户不存在时返回错误

3. **影响范围**
   - 对方不再出现在你的粉丝列表中
   - 对方无法再看到你的动态（如果设置了隐私）
   - 对方无法再给你发消息（如果设置了隐私）

#### 🎨 前端展示建议

**粉丝列表页面：**
```javascript
// 粉丝列表项
<UserCard 
  v-for="follower in followersList"
  :key="follower.userId"
  :user="follower"
>
  <button 
    @click="removeFollower(follower.userId)"
    class="btn-remove"
  >
    移除粉丝
  </button>
</UserCard>

// 移除粉丝方法
async removeFollower(followerId) {
  try {
    await api.delete(`/user/followers/${followerId}`);
    this.showToast('已移除粉丝');
    // 刷新列表
    this.loadFollowers();
  } catch (error) {
    if (error.code === 40004) {
      this.showToast('该用户不是你的粉丝');
    } else {
      this.showToast('移除失败，请重试');
    }
  }
}
```

**用户资料页面（查看他人）：**
```javascript
// 如果是我的粉丝，显示"移除粉丝"按钮
<button 
  v-if="isMyFollower"
  @click="removeFollower"
  class="btn-remove-follower"
>
  移除粉丝
</button>
```

#### 🎯 前端注意事项

1. **权限判断**
   - 只有查看自己的粉丝列表时才能移除
   - 查看他人资料时，如果对方是我的粉丝，也可以移除

2. **确认提示**
   - 建议添加确认对话框，避免误操作
   ```javascript
   async removeFollower(followerId) {
     const confirmed = await this.showConfirm('确定要移除该粉丝吗？');
     if (!confirmed) return;
     // 执行移除操作
   }
   ```

3. **列表刷新**
   - 移除成功后需要刷新粉丝列表
   - 或者从列表中移除该项

4. **错误处理**
   - 40001：不能移除自己
   - 40004：该用户不是你的粉丝
   - 404：用户不存在

#### ✨ 优化效果
- ✅ 用户可以主动管理粉丝列表
- ✅ 保护用户隐私和社交环境
- ✅ 完善关注功能的闭环
- ✅ 提升用户体验和安全感

---

### 9. 新增：编辑动态接口

#### 🎯 优化目标
补充编辑动态功能，允许用户修改已发布的动态内容，提升用户体验和内容管理灵活性。

#### ❌ 原有问题
1. **缺少编辑功能**
   - 用户发布动态后无法修改
   - 发现错误或需要更新内容时只能删除重发
   - 影响用户体验和内容质量

2. **活动管理不便**
   - 活动信息需要调整时无法修改
   - 只能删除后重新发布，丢失已有报名数据

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `PUT /api/moments/{momentId}` | 编辑动态 |

#### 📥 请求参数

**请求方式：** `PUT`  
**路径参数：**

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| momentId | Long | 是 | 动态ID | `123` |

**请求体（JSON）：**

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| content | String | 否 | 动态内容，最多1000字 | `"更新后的内容"` |
| title | String | 否 | 标题（活动类型），最多100字 | `"周末爬山活动"` |
| location | String | 否 | 位置信息 | `"朝阳公园"` |
| latitude | Decimal | 否 | 纬度 | `39.9042` |
| longitude | Decimal | 否 | 经度 | `116.4074` |
| city | String | 否 | 城市 | `"北京"` |
| photoUrls | Array | 否 | 图片URLs数组，最多9张（会替换所有旧图片） | `["url1", "url2"]` |
| activityTime | DateTime | 否 | 活动时间（活动类型，且无人报名时可修改） | `"2025-12-10 14:00:00"` |
| activityType | String | 否 | 活动类型 | `"sport"` |
| maxParticipants | Integer | 否 | 最大参与人数（不能小于当前报名人数） | `10` |
| activityFee | Decimal | 否 | 活动费用 | `30.00` |
| contactMethod | String | 否 | 联系方式 | `"微信：xxx"` |

#### 📋 请求示例

**编辑普通动态：**
```bash
curl -X PUT "http://localhost:8080/api/moments/123" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "content": "更新后的动态内容",
    "location": "新位置",
    "latitude": 39.9042,
    "longitude": 116.4074,
    "city": "北京",
    "photoUrls": ["https://oss.example.com/new1.jpg"]
  }'
```

**编辑活动动态：**
```bash
curl -X PUT "http://localhost:8080/api/moments/456" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "更新后的活动标题",
    "content": "更新后的活动描述",
    "activityTime": "2025-12-10 14:00:00",
    "maxParticipants": 10,
    "activityFee": 30.00,
    "contactMethod": "微信：new_contact"
  }'
```

#### 📤 响应示例

```json
{
  "code": 200,
  "message": "编辑成功",
  "data": {
    "momentId": 123,
    "userId": "U1699123456789AB12CD",
    "momentType": 1,
    "content": "更新后的动态内容",
    "location": "新位置",
    "latitude": 39.9042,
    "longitude": 116.4074,
    "city": "北京",
    "photoUrls": ["https://oss.example.com/new1.jpg"],
    "likeCount": 5,
    "commentCount": 2,
    "isLiked": false,
    "createdAt": "2025-12-08 10:00:00",
    "updatedAt": "2025-12-08 15:30:00"
  }
}
```

#### 🔄 业务逻辑说明

1. **权限验证**
   - 只能编辑自己发布的动态
   - 动态不存在或已删除时无法编辑

2. **活动类型特殊限制**
   - **已有人报名的活动：**
     - ❌ 不能修改活动时间（避免影响已报名用户）
     - ✅ 可以修改其他字段（标题、内容、费用、联系方式等）
     - ⚠️ 最大参与人数只能增加或保持不变，不能减少到小于当前报名人数
   - **无人报名的活动：**
     - ✅ 可以修改所有字段，包括活动时间

3. **图片更新规则**
   - 如果传入 `photoUrls` 数组，会**完全替换**所有旧图片
   - 传入空数组会删除所有图片
   - 不传 `photoUrls` 字段则保持原有图片不变

4. **字段更新规则**
   - 只更新传入的字段，未传入的字段保持原值不变
   - 所有字段都是可选的，可以只更新部分字段

5. **活动状态自动更新**
   - 如果修改最大参与人数后，当前报名人数等于最大人数，活动状态自动变为"已满员"
   - 如果修改最大参与人数后，当前报名人数小于最大人数，且原状态为"已满员"，活动状态恢复为"招募中"

#### ⚠️ 错误码

| 错误码 | 说明 |
|--------|------|
| 40005 | 动态不存在或已删除 |
| 40006 | 只能编辑自己的动态 |
| 40012 | 活动已有人报名，不能修改活动时间 |
| 40013 | 最大人数不能小于当前报名人数 |

#### 💻 前端集成示例

**动态详情页（编辑按钮）：**
```javascript
// 在动态详情页显示编辑按钮（仅自己的动态）
<button 
  v-if="moment.userId === currentUserId"
  @click="editMoment"
  class="btn-edit"
>
  编辑
</button>

// 编辑方法
async editMoment() {
  // 跳转到编辑页面，传递动态ID和当前数据
  this.$router.push({
    path: '/moment/edit',
    query: { momentId: this.moment.momentId }
  });
}
```

**编辑页面：**
```javascript
// 加载动态数据
async loadMoment() {
  const res = await api.get(`/moments/${this.momentId}`);
  this.form = {
    content: res.data.content,
    location: res.data.location,
    latitude: res.data.latitude,
    longitude: res.data.longitude,
    city: res.data.city,
    photoUrls: res.data.photoUrls || [],
    // ... 其他字段
  };
}

// 提交编辑
async submitEdit() {
  try {
    const res = await api.put(`/moments/${this.momentId}`, this.form);
    this.showToast('编辑成功');
    // 返回详情页并刷新
    this.$router.back();
  } catch (error) {
    if (error.code === 40012) {
      this.showToast('活动已有人报名，不能修改活动时间');
    } else if (error.code === 40013) {
      this.showToast(`最大人数不能小于当前报名人数（${error.data}人）`);
    } else {
      this.showToast('编辑失败，请重试');
    }
  }
}
```

#### 🎯 前端注意事项

1. **权限判断**
   - 只有动态发布者才能看到编辑按钮
   - 编辑前需要验证权限

2. **活动类型特殊处理**
   - 如果活动已有人报名，前端应该禁用活动时间字段
   - 显示提示："活动已有人报名，活动时间不可修改"
   - 最大参与人数输入框需要验证最小值（当前报名人数）

3. **图片处理**
   - 编辑时显示当前图片，允许删除和重新上传
   - 图片更新会完全替换，需要提示用户

4. **表单验证**
   - 保持与发布动态相同的验证规则
   - 活动类型需要验证活动时间不能早于当前时间

5. **用户体验**
   - 编辑成功后刷新动态详情页
   - 显示编辑时间戳（`updatedAt`）
   - 可以添加"编辑历史"功能（可选）

#### ✨ 优化效果
- ✅ 用户可以修改已发布的动态内容
- ✅ 活动信息可以灵活调整，无需删除重发
- ✅ 提升用户体验和内容管理灵活性
- ✅ 保护已报名用户权益（活动时间不可随意修改）

---

### 10. 新增：查看我喜欢谁接口

#### 🎯 优化目标
补充"我喜欢谁"功能，让用户可以查看自己主动喜欢过的所有用户列表，与"谁喜欢我"形成完整的匹配管理闭环。

#### ❌ 原有问题
1. **缺少我喜欢谁功能**
   - 用户无法查看自己主动喜欢过的用户
   - 只有"谁喜欢我"接口，缺少对称功能
   - 无法管理自己的喜欢记录

2. **匹配管理不完整**
   - 用户不知道自己喜欢了哪些人
   - 无法查看是否已匹配成功
   - 缺少完整的匹配历史管理

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `GET /api/matching/i-liked` | 查看我喜欢谁 |

#### 📥 请求参数

**请求方式：** `GET`

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| page | Integer | 否 | 页码，默认1 | `1` |
| size | Integer | 否 | 每页数量，默认10 | `10` |

#### 📋 请求示例

```bash
curl -X GET "http://localhost:8080/api/matching/i-liked?page=1&size=10" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

#### 📤 响应示例

```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "records": [
      {
        "userId": "U1699123456789AB12CD",
        "nickname": "小红",
        "avatar": "https://example.com/avatar.jpg",
        "age": 25,
        "gender": 2,
        "height": 165,
        "occupation": "设计师",
        "education": "本科",
        "incomeRange": "15-20万",
        "city": "北京",
        "distance": 1800,
        "distanceText": "1.8km",
        "bio": "喜欢画画和旅行",
        "interestTags": ["绘画", "旅行", "摄影"],
        "photos": ["https://example.com/photo1.jpg"],
        "matchScore": 85.0,
        "onlineStatus": 1,
        "isRealNameVerified": 1,
        "isLiked": 1,
        "likedMe": 1
      }
    ],
    "total": 8,
    "size": 10,
    "current": 1,
    "pages": 1
  }
}
```

#### 📤 返回字段说明

| 字段名 | 类型 | 说明 | 值 |
|--------|------|------|-----|
| `isLiked` | Integer | 是否喜欢了对方 | 始终为 `1`（因为这些都是用户主动喜欢的） |
| `likedMe` | Integer | 对方是否也喜欢我 | `1` 表示双向匹配，`0` 表示单向喜欢 |

#### 🔄 业务逻辑说明

1. **查询范围**
   - 返回当前用户主动喜欢（包括普通喜欢和超级喜欢）的所有用户
   - 不包括"跳过"记录
   - 如果用户已取消喜欢，不会出现在列表中

2. **排序规则**
   - 优先显示超级喜欢（`matchType = 2`）
   - 然后按喜欢时间倒序排列（最近喜欢的在前）

3. **匹配状态**
   - `likedMe = 1`：双向匹配成功，双方互相喜欢
   - `likedMe = 0`：单向喜欢，对方还未回应

4. **数据过滤**
   - 只返回审核通过且未删除的用户
   - 自动计算距离（如果用户有位置信息）

#### 🎨 前端展示建议

**"我喜欢谁"列表页面：**
```javascript
// 列表项展示
<UserCard 
  v-for="user in iLikedList"
  :key="user.userId"
  :user="user"
>
  <!-- 匹配状态标识 -->
  <view class="match-status">
    <text v-if="user.likedMe === 1" class="matched">
      ✅ 已匹配
    </text>
    <text v-else class="pending">
      ⏳ 等待回应
    </text>
  </view>
  
  <!-- 操作按钮 -->
  <view class="actions">
    <button v-if="user.likedMe === 1" @click="startChat">
      开始聊天
    </button>
    <button @click="cancelLike(user.userId)">
      取消喜欢
    </button>
  </view>
</UserCard>
```

**页面布局建议：**
```
┌─────────────────────────────────┐
│  我喜欢谁 (8)                    │
├─────────────────────────────────┤
│ ┌─────────────────────────────┐ │
│ │ 小红，25岁                   │ │
│ │ ✅ 已匹配                    │ │
│ │ 距离 1.8km · 匹配度 85分     │ │
│ │ [开始聊天] [取消喜欢]        │ │
│ └─────────────────────────────┘ │
│                                 │
│ ┌─────────────────────────────┐ │
│ │ 小美，23岁                   │ │
│ │ ⏳ 等待回应                  │ │
│ │ 距离 2.5km · 匹配度 78分     │ │
│ │ [取消喜欢]                  │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

**代码示例：**
```javascript
// 加载我喜欢谁列表
async loadILikedList() {
  try {
    const res = await api.get('/matching/i-liked', {
      params: {
        page: this.page,
        size: this.size
      }
    });
    this.iLikedList = res.data.records;
    this.total = res.data.total;
  } catch (error) {
    this.showToast('加载失败，请重试');
  }
},

// 取消喜欢
async cancelLike(userId) {
  try {
    await api.delete('/matching/like', {
      data: { toUserId: userId }
    });
    this.showToast('已取消喜欢');
    // 刷新列表
    this.loadILikedList();
  } catch (error) {
    this.showToast('取消失败，请重试');
  }
}
```

#### 🎯 前端注意事项

1. **状态展示**
   - `likedMe = 1` 时显示"已匹配"，可以开始聊天
   - `likedMe = 0` 时显示"等待回应"，只能取消喜欢

2. **列表刷新**
   - 取消喜欢后需要刷新列表
   - 如果对方也喜欢了我，`likedMe` 状态会自动更新

3. **与"谁喜欢我"的区别**
   - "谁喜欢我"：`likedMe = 1`，`isLiked` 可能为 0 或 1
   - "我喜欢谁"：`isLiked = 1`，`likedMe` 可能为 0 或 1

4. **空状态处理**
   - 如果列表为空，显示"还没有喜欢过任何人"

#### ✨ 优化效果
- ✅ 用户可以查看自己主动喜欢过的所有用户
- ✅ 清晰展示匹配状态（已匹配/等待回应）
- ✅ 与"谁喜欢我"形成完整的匹配管理闭环
- ✅ 提升用户体验和匹配管理效率

---

### 11. 优化：动态列表接口支持距离计算

#### 🎯 优化目标
为动态列表和详情接口添加距离计算功能，让用户可以直观看到动态发布位置与自己的距离，提升用户体验和活动参与意愿。

#### ❌ 原有问题
1. **缺少距离信息**
   - 动态列表和详情中不显示距离
   - 用户无法判断活动或动态的远近
   - 影响用户参与活动的决策

2. **位置信息未利用**
   - 动态有位置信息（经纬度）但未计算距离
   - 用户需要手动判断位置远近

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `GET /api/moments/list` | 获取动态列表 |
| `GET /api/moments/{momentId}` | 获取动态详情 |
| `GET /api/moments/search` | 搜索动态 |

#### 📥 请求参数变化

**GET /api/moments/list** 接口新增可选参数：

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| latitude | Decimal | 否 | 当前用户纬度（用于距离计算） | `39.9042` |
| longitude | Decimal | 否 | 当前用户经度（用于距离计算） | `116.4074` |

**说明：**
- 如果传入了 `latitude` 和 `longitude`，使用传入的坐标计算距离
- 如果未传入，系统会尝试从当前用户的匹配偏好或用户资料中获取位置信息
- 只有当动态有位置信息且当前用户有位置信息时，才会计算并返回距离

#### 📤 返回数据新增字段

在所有动态相关的接口返回中，新增以下字段：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `distance` | Integer | 距离（单位：米），当动态和当前用户都有位置信息时返回，否则为null | `1250` |
| `distanceDesc` | String | 距离描述（格式化文本），当distance不为null时返回 | `"1.2km"` |

#### 📋 完整返回示例

**优化前：** ❌
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "id": 1,
        "title": "周末羽毛球活动",
        "location": "朝阳体育馆",
        "city": "北京",
        "likeCount": 5,
        "commentCount": 2
      }
    ]
  }
}
```

**优化后：** ✅
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "id": 1,
        "title": "周末羽毛球活动",
        "location": "朝阳体育馆",
        "city": "北京",
        "likeCount": 5,
        "commentCount": 2,
        "distance": 1250,
        "distanceDesc": "1.2km",
        "timeDesc": "2小时前"
      }
    ],
    "total": 50,
    "current": 1,
    "size": 10
  }
}
```

#### 🔄 业务逻辑说明

1. **距离计算规则**
   - 使用 Haversine 公式计算两点间的大圆距离
   - 地球半径：6371000 米
   - 返回距离单位为米（整数）

2. **距离格式化规则**
   - `< 1000m`：显示为 `"500m"`
   - `1-10km`：显示为 `"1.2km"`（保留一位小数）
   - `≥ 10km`：显示为 `"10km"`（整数，不显示小数）

3. **位置信息来源优先级**
   - **第一优先级**：请求参数中传入的 `latitude` 和 `longitude`
   - **第二优先级**：当前用户的匹配偏好中的位置信息（`MatchingPreference.locationLatitude`、`locationLongitude`）
   - **第三优先级**：当前用户的用户资料中的位置信息（`UserProfile.locationLatitude`、`locationLongitude`）

4. **距离计算条件**
   - 动态必须有位置信息（`Moment.latitude` 和 `longitude` 不为null）
   - 当前用户必须有位置信息（通过上述优先级获取）
   - 两个条件都满足时才会计算并返回距离

#### 🎨 前端展示建议

**动态列表页面：**
```javascript
// 动态卡片组件
<View className="moment-card">
  <Text className="title">{{ moment.title }}</Text>
  <View className="location-info">
    <Icon type="location" />
    <Text>{{ moment.location }}</Text>
    <!-- 显示距离 -->
    <Text v-if="moment.distanceDesc" className="distance">
      · {{ moment.distanceDesc }}
    </Text>
  </View>
  <Text className="time">{{ moment.timeDesc }}</Text>
</View>
```

**动态详情页面：**
```javascript
// 详情页位置信息展示
<View className="moment-detail">
  <View className="location-section">
    <Icon type="location" />
    <Text className="location-name">{{ moment.location }}</Text>
    <Text v-if="moment.distanceDesc" className="distance">
      距离你 {{ moment.distanceDesc }}
    </Text>
  </View>
</View>
```

**页面布局示例：**
```
┌─────────────────────────────────┐
│ 周末羽毛球活动                   │
│                                  │
│ 📍 朝阳体育馆 · 1.2km           │
│                                  │
│ 找3个小伙伴一起打羽毛球          │
│                                  │
│ 👍 5  💬 2  ⏰ 2小时前          │
└─────────────────────────────────┘
```

**代码示例：**
```javascript
// 获取动态列表时传入位置信息
async loadMomentList() {
  // 获取用户当前位置
  const location = await this.getUserLocation();
  
  const res = await api.get('/moments/list', {
    params: {
      momentType: this.momentType,
      page: this.page,
      size: this.size,
      // 传入位置信息用于计算距离
      latitude: location.latitude,
      longitude: location.longitude
    }
  });
  
  this.momentList = res.data.records;
}

// 获取用户位置
async getUserLocation() {
  return new Promise((resolve, reject) => {
    wx.getLocation({
      type: 'gcj02',
      success: (res) => {
        resolve({
          latitude: res.latitude,
          longitude: res.longitude
        });
      },
      fail: (err) => {
        // 如果获取位置失败，不传位置参数，后端会尝试从用户资料获取
        resolve(null);
      }
    });
  });
}
```

#### 🎯 前端注意事项

1. **位置权限**
   - 建议在首次使用时请求位置权限
   - 如果用户拒绝授权，不传位置参数，后端会尝试从用户资料获取

2. **距离显示**
   - `distance` 和 `distanceDesc` 可能为 `null`（当没有位置信息时）
   - 前端需要判断字段是否存在再显示

3. **性能优化**
   - 位置信息变化不频繁，可以缓存用户位置
   - 避免每次请求都调用 `wx.getLocation`

4. **用户体验**
   - 距离信息建议显示在位置信息旁边
   - 活动类型的动态，距离信息更重要，可以突出显示
   - 可以根据距离远近排序或筛选（前端实现）

5. **搜索接口**
   - 搜索动态接口也会自动计算距离（从用户资料获取位置）
   - 无需额外传参

#### 🔄 距离计算公式

使用 Haversine 公式计算两点间的大圆距离：

```
a = sin²(Δlat/2) + cos(lat1) × cos(lat2) × sin²(Δlon/2)
c = 2 × atan2(√a, √(1-a))
distance = R × c

其中：
- R = 6371000 米（地球半径）
- lat1, lon1 = 当前用户位置
- lat2, lon2 = 动态位置
```

#### ✨ 优化效果
- ✅ 用户可以直观看到动态与自己的距离
- ✅ 提升活动参与决策效率
- ✅ 支持按距离筛选和排序（前端实现）
- ✅ 自动从用户资料获取位置，无需每次传参
- ✅ 距离格式化显示，用户体验更好

#### ⚠️ 注意事项
- 距离计算需要动态和用户都有位置信息
- 如果位置信息不完整，`distance` 和 `distanceDesc` 字段为 `null`
- 前端需要处理字段为 `null` 的情况

---

### 12. 新增：快速更新位置接口

#### 🎯 优化目标
提供便捷的位置更新接口，让用户可以快速更新自己的位置信息，用于匹配推荐和距离计算。

#### ❌ 原有问题
1. **位置更新方式复杂**
   - 需要通过"更新资料"接口更新 `UserProfile` 中的位置
   - 需要通过"设置匹配偏好"接口更新 `MatchingPreference` 中的位置
   - 需要调用两个接口才能完整更新位置信息

2. **用户体验不佳**
   - 用户移动后需要更新位置，但操作繁琐
   - 位置信息分散在两个表中，容易不一致

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `POST /api/user/location` | 快速更新用户位置 |

#### 📥 请求参数

**请求方式：** `POST`  
**Content-Type：** `application/json`

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| latitude | Decimal | 是 | 纬度 | `39.908823` |
| longitude | Decimal | 是 | 经度 | `116.397470` |
| city | String | 否 | 城市简称（用于显示） | `"北京"` |

#### 📋 请求示例

```bash
curl -X POST "http://localhost:8080/api/user/location" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "latitude": 39.908823,
    "longitude": 116.397470,
    "city": "北京"
  }'
```

**请求Body：**
```json
{
  "latitude": 39.908823,
  "longitude": 116.397470,
  "city": "北京"
}
```

#### 📤 响应示例

```json
{
  "code": 200,
  "message": "位置更新成功",
  "data": true
}
```

#### 🔄 业务逻辑说明

1. **同时更新两个位置**
   - 更新 `UserProfile` 表中的位置信息（`locationLatitude`、`locationLongitude`、`currentCity`）
   - 更新 `MatchingPreference` 表中的位置信息（`locationLatitude`、`locationLongitude`）
   - 如果记录不存在，会自动创建

2. **位置信息来源优先级**
   - 动态列表接口在计算距离时，会按以下优先级获取用户位置：
     1. **最高优先级**：请求参数中传入的 `latitude` 和 `longitude`
     2. **第二优先级**：`MatchingPreference` 中的位置信息
     3. **第三优先级**：`UserProfile` 中的位置信息

3. **使用场景**
   - 用户移动后需要更新位置
   - 首次设置位置信息
   - 定期更新位置以获取更准确的匹配推荐和距离计算

#### 🎨 前端展示建议

**位置更新页面：**
```javascript
// 位置更新组件
export default {
  data() {
    return {
      location: {
        latitude: null,
        longitude: null,
        city: ''
      }
    }
  },
  
  methods: {
    // 自动获取并更新位置
    async autoUpdateLocation() {
      try {
        // 获取当前位置
        const location = await this.getCurrentLocation();
        
        // 调用更新接口
        await api.post('/user/location', {
          latitude: location.latitude,
          longitude: location.longitude,
          city: location.city
        });
        
        this.showToast('位置更新成功');
        // 刷新动态列表以获取新的距离信息
        this.refreshMomentList();
      } catch (error) {
        if (error.errMsg && error.errMsg.includes('auth deny')) {
          this.showToast('需要位置权限才能更新位置');
        } else {
          this.showToast('位置更新失败，请重试');
        }
      }
    },
    
    // 获取当前位置
    getCurrentLocation() {
      return new Promise((resolve, reject) => {
        wx.getLocation({
          type: 'gcj02', // 返回可以用于地图的坐标类型
          success: (res) => {
            resolve({
              latitude: res.latitude,
              longitude: res.longitude,
              city: '' // 可以通过逆地理编码API获取城市名称
            });
          },
          fail: (err) => {
            reject(err);
          }
        });
      });
    },
    
    // 手动输入位置（如果用户拒绝位置权限）
    async manualUpdateLocation() {
      // 显示位置选择器或输入框
      // 用户选择城市后，可以调用接口更新
      await api.post('/user/location', {
        latitude: this.selectedLatitude,
        longitude: this.selectedLongitude,
        city: this.selectedCity
      });
    }
  },
  
  onLoad() {
    // 页面加载时自动更新位置
    this.autoUpdateLocation();
  }
}
```

**位置更新时机建议：**
- 用户首次登录时
- 用户主动点击"更新位置"按钮
- 定期自动更新（如每30分钟）
- 进入动态列表页面时（如果位置信息缺失）

#### 🎯 前端注意事项

1. **位置权限**
   - 首次调用需要请求位置权限
   - 如果用户拒绝，可以提示手动选择城市

2. **更新频率**
   - 建议不要过于频繁更新（避免频繁调用接口）
   - 可以缓存位置信息，只在位置变化较大时更新

3. **城市信息**
   - `city` 字段是可选的，主要用于显示
   - 可以通过逆地理编码API根据经纬度获取城市名称

4. **错误处理**
   - 位置权限被拒绝时，提示用户手动选择
   - 网络错误时，提示用户稍后重试

#### 📝 其他位置更新方式

除了快速更新位置接口，还可以通过以下方式更新位置：

1. **通过更新资料接口**
   - `POST /api/user/profile/update`
   - 传入 `locationLatitude`、`locationLongitude`、`currentCity`
   - 只更新 `UserProfile` 表

2. **通过设置匹配偏好接口**
   - `POST /api/matching/preference`
   - 传入 `locationLatitude`、`locationLongitude`
   - 只更新 `MatchingPreference` 表

3. **更新动态/活动位置**
   - `PUT /api/moments/{momentId}`
   - 传入 `latitude`、`longitude`、`location`、`city`
   - 更新动态的位置信息（用于距离计算）

**推荐使用：** 快速更新位置接口（`POST /api/user/location`），一次调用同时更新两个表。

#### ✨ 优化效果
- ✅ 一次调用同时更新两个位置表，操作更便捷
- ✅ 位置信息保持一致，避免数据不一致
- ✅ 提升用户体验，位置更新更简单
- ✅ 支持自动更新位置，提升匹配和距离计算准确性

---

### 13. 新增：快速获取位置接口

#### 🎯 优化目标
提供便捷的位置查询接口，让前端可以快速获取用户的位置信息，用于判断是否需要引导用户设置位置。

#### ❌ 原有问题
1. **获取位置信息不便**
   - 需要通过"查看我的资料"接口获取完整资料，数据量大
   - 无法快速判断用户是否已设置位置
   - 前端需要解析大量数据才能获取位置信息

2. **缺少位置状态检查**
   - 无法快速检查用户位置信息是否完整
   - 无法判断位置信息来源

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `GET /api/user/location` | 快速获取用户位置 |

#### 📥 请求参数

**请求方式：** `GET`  
**无需参数**

#### 📋 请求示例

```bash
curl -X GET "http://localhost:8080/api/user/location" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

#### 📤 响应示例

**有位置信息时：**
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "latitude": 39.908823,
    "longitude": 116.397470,
    "city": "北京",
    "source": 3
  }
}
```

**无位置信息时：**
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "latitude": null,
    "longitude": null,
    "city": null,
    "source": 0
  }
}
```

#### 📤 返回字段说明

| 字段名 | 类型 | 说明 | 值 |
|--------|------|------|-----|
| `latitude` | Decimal | 纬度 | 有位置信息时返回，否则为null |
| `longitude` | Decimal | 经度 | 有位置信息时返回，否则为null |
| `city` | String | 城市简称 | 有位置信息时返回，否则为null |
| `source` | Integer | 位置信息来源 | 0-无位置信息，1-UserProfile，2-MatchingPreference，3-两者都有 |

#### 🔄 业务逻辑说明

1. **位置信息来源优先级**
   - 优先返回 `MatchingPreference` 中的位置信息（用于匹配推荐）
   - 如果 `MatchingPreference` 中没有，返回 `UserProfile` 中的位置信息
   - 如果两者都没有，返回 `null`

2. **source 字段说明**
   - `0`：没有位置信息，需要引导用户设置
   - `1`：只有 `UserProfile` 中有位置信息
   - `2`：只有 `MatchingPreference` 中有位置信息（推荐）
   - `3`：两个表中都有位置信息（最完整）

3. **使用场景**
   - 检查用户是否已设置位置
   - 获取当前位置用于地图展示
   - 判断是否需要引导用户设置位置
   - 在动态列表加载前检查位置信息

#### 🎨 前端展示建议

**位置检查组件：**
```javascript
// 检查并引导设置位置
async checkLocation() {
  try {
    const res = await api.get('/user/location');
    const location = res.data;
    
    if (!location.latitude || !location.longitude) {
      // 没有位置信息，显示引导
      this.showLocationSetupGuide();
      return false;
    }
    
    // 有位置信息，可以使用
    this.currentLocation = location;
    return true;
  } catch (error) {
    this.showToast('获取位置失败');
    return false;
  }
},

// 显示位置设置引导
showLocationSetupGuide() {
  wx.showModal({
    title: '设置位置',
    content: '设置位置信息可以获得更准确的匹配推荐和距离计算',
    confirmText: '去设置',
    cancelText: '稍后',
    success: (res) => {
      if (res.confirm) {
        // 跳转到位置设置页面
        wx.navigateTo({
          url: '/pages/location-setup/index'
        });
      }
    }
  });
}
```

**动态列表页面（加载前检查）：**
```javascript
// 在加载动态列表前检查位置
async loadMomentList() {
  // 1. 先检查位置信息
  const hasLocation = await this.checkLocation();
  
  // 2. 获取当前位置（如果有）
  let locationParams = {};
  if (hasLocation && this.currentLocation) {
    locationParams = {
      latitude: this.currentLocation.latitude,
      longitude: this.currentLocation.longitude
    };
  }
  
  // 3. 加载动态列表
  const res = await api.get('/moments/list', {
    params: {
      ...locationParams,
      page: this.page,
      size: this.size
    }
  });
  
  this.momentList = res.data.records;
}
```

#### 🎯 前端注意事项

1. **位置检查时机**
   - 建议在用户首次进入动态列表时检查
   - 如果位置信息缺失，引导用户设置

2. **source 字段使用**
   - `source = 0`：需要引导用户设置位置
   - `source = 1` 或 `2`：位置信息可用，但建议同步到两个表
   - `source = 3`：位置信息完整

3. **性能优化**
   - 可以缓存位置信息，避免频繁调用
   - 位置信息变化不频繁，可以设置较长的缓存时间

4. **错误处理**
   - 如果接口返回错误，可以降级使用"查看我的资料"接口

#### ✨ 优化效果
- ✅ 快速获取位置信息，无需加载完整资料
- ✅ 可以判断位置信息是否完整
- ✅ 支持引导用户设置位置
- ✅ 提升用户体验和位置管理效率

---

## 📌 待优化项

### 性能优化
- [ ] 用户卡片社交统计数据添加 Redis 缓存
- [ ] 匹配推荐结果缓存优化
- [ ] 数据库查询索引优化

### 功能完善
- [ ] 关注/粉丝功能实现（目前返回0）
- [ ] 收藏功能完善
- [ ] 用户反馈系统

### 体验优化
- [ ] 匹配推荐算法权重调优
- [ ] 个性化推荐增强
- [ ] 消息推送优化

---

## 🔖 版本记录

| 版本 | 日期 | 优化项数量 | 主要内容 |
|------|------|-----------|----------|
| v1.0 | 2025-12-06 | 3 | 时间格式修复、分级降级策略、社交统计数据 |
| v1.1 | 2025-12-07 | 3 | 评论系统树形结构、搭子匹配模式、用户资料增强 |
| v1.2 | 2025-12-08 | 7 | 取消喜欢接口、移除粉丝接口、编辑动态接口、查看我喜欢谁接口、动态距离计算、快速更新位置接口、快速获取位置接口 |

---

## 📝 接口优化记录规范

### 记录格式

每个优化项应包含以下内容（**按接口视角**）：

#### 必填项
1. **🎯 优化目标/问题描述**：说明为什么要优化
2. **📌 涉及接口**：列出所有受影响的 API 接口（方法 + URL）
3. **📥 请求参数变化**（如有）：新增/修改/删除的参数
4. **📤 返回数据变化**（如有）：新增/修改的字段
5. **✨ 优化效果**：对前端的影响和收益

#### 可选项
6. **⚠️ 前端注意事项**：需要前端配合修改的地方
7. **🎨 前端展示建议**：UI/UX 建议
8. **📋 完整示例**：请求/响应完整 JSON 示例

### 提交流程

```
1. 后端完成优化
   ↓
2. 立即记录到本文档（在对应日期下）
   ↓
3. 更新文档顶部"最后更新"时间
   ↓
4. 通知前端查看优化记录
   ↓
5. 前端根据记录调整代码
```

### 命名规范

- **修复类**：修复：XXX 接口问题
- **优化类**：优化：XXX 接口功能增强
- **新增类**：新增：XXX 字段/功能

### 示例模板

```markdown
### X. 优化：XXX接口功能增强

#### 🎯 优化目标
简要说明优化原因

#### 📌 涉及接口
- **GET** `/api/xxx/xxx`
- **POST** `/api/xxx/xxx`

#### 📥 请求参数变化
| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| xxx | String | 是 | xxx | "xxx" |

#### 📤 返回数据新增字段
| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| xxx | Integer | xxx | 123 |

#### 🎯 前端注意事项
- 注意事项1
- 注意事项2

#### ✨ 优化效果
- ✅ 效果1
- ✅ 效果2
```

---

## 📞 联系方式

**问题反馈：**
- 前端发现接口问题 → 联系后端开发
- 后端优化接口 → 在本文档记录并通知前端

**文档维护：** 后端开发团队  
**查看方式：** `friends-ui/docs/系统优化记录.md`
