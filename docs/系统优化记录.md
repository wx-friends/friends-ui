# 碰碰小程序接口优化记录

## 文档信息
- **创建时间**：2025-12-07
- **最后更新**：2025-12-08
- **作者**：后端开发团队
- **说明**：记录接口变更、优化和Bug修复，供前端对接参考
- **Base URL**：`http://localhost:8080`

---

## 📋 优化目录

- [2025-12-06 接口优化](#2025-12-06-接口优化)
  - [修复：发布活动接口时间格式问题](#1-修复发布活动接口时间格式问题)
  - [优化：推荐用户接口返回数据增强](#2-优化推荐用户接口返回数据增强)
  - [新增：用户卡片统计数据字段](#3-新增用户卡片统计数据字段)

- [2025-12-07 接口优化](#2025-12-07-接口优化)
  - [重构：评论系统支持多级树形结构](#4-重构评论系统支持多级树形结构)
  - [新增：搭子匹配模式和设置字段](#5-新增搭子匹配模式和设置字段)
  - [增强：用户资料接口返回数据](#6-增强用户资料接口返回数据)

- [2025-12-08 接口优化](#2025-12-08-接口优化)
  - [新增：取消喜欢接口](#7-新增取消喜欢接口)
  - [新增：移除粉丝接口](#8-新增移除粉丝接口)

---

## 2025-12-06 接口优化

### 1. 修复：发布活动接口时间格式问题

#### 🔧 问题描述
发布活动时，后端无法正确解析前端传递的时间格式，导致 400 错误。

#### 📌 涉及接口
**POST** `/api/moments/publish`

#### ⚠️ 问题表现
请求时返回错误：
```json
{
  "code": 400,
  "message": "时间格式错误"
}
```

#### ✅ 解决方案
后端已修复，现在支持前端常用的时间格式。

#### 📥 请求参数（仅活动类型需要）

**修复前：** ❌ 不支持空格分隔的时间格式  
**修复后：** ✅ 支持以下格式

```json
{
  "momentType": 3,
  "activityTime": "2025-12-06 00:00:00",  // ✅ 推荐：空格分隔
  "title": "周末爬山活动",
  "content": "约几个朋友一起爬山",
  // ... 其他字段
}
```

**时间格式说明：**
- ✅ 支持格式：`"2025-12-06 00:00:00"`（空格分隔）
- ✅ 也支持：`"2025-12-06T00:00:00"`（ISO-8601）

#### 🎯 前端注意事项
- 使用常规的 `YYYY-MM-DD HH:mm:ss` 格式即可
- 无需转换为ISO格式
- 仅在 `momentType=3`（活动）或 `momentType=4`（官方活动）时需要传递此字段

---

### 2. 优化：推荐用户接口返回数据增强

#### 🎯 优化目标
解决用户偏好设置严格时找不到匹配对象的问题，提供更智能的推荐策略。

#### 📌 涉及接口
**GET** `/api/matching/recommend`

#### 📤 返回数据新增字段

在每个用户卡片对象中新增 `matchLevel` 字段，表示匹配质量等级：

```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "userId": "U1699123456789AB12CD",
        "nickname": "小明",
        "matchLevel": 1,  // ✨ 新增字段
        // ... 其他字段
      }
    ],
    "total": 50
  }
}
```

#### 📊 matchLevel 字段说明

| matchLevel 值 | 匹配质量 | 说明 | 前端建议展示 |
|--------------|---------|------|-------------|
| `1` | 严格匹配 | 完全符合用户设置的所有偏好 | ⭐⭐⭐ "完全匹配" |
| `2` | 标准匹配 | 大部分条件符合，略微放宽 | ⭐⭐ "高度匹配" |
| `3` | 宽松匹配 | 核心条件符合（性别、大致年龄） | ⭐ "推荐给你" |
| `4` | 兜底推荐 | 保证有推荐结果 | "附近的人" |

#### 🎨 前端展示建议

**推荐列表页面：**
```javascript
// 根据 matchLevel 显示不同标识
const getLevelTag = (level) => {
  switch(level) {
    case 1: return { text: '完全匹配', icon: '⭐⭐⭐', color: '#FF6B6B' };
    case 2: return { text: '高度匹配', icon: '⭐⭐', color: '#4ECDC4' };
    case 3: return { text: '推荐给你', icon: '⭐', color: '#95E1D3' };
    case 4: return { text: '附近的人', icon: '', color: '#999' };
  }
}
```

**效果展示：**
```
┌─────────────────────────┐
│ 小明，25岁              │
│ ⭐⭐⭐ 完全匹配         │ ← matchLevel = 1
│ 匹配度 85.5分           │
│ 距离 1.2km              │
└─────────────────────────┘
```

#### 💡 业务逻辑说明

后端会按以下优先级推荐：
1. 优先返回 `matchLevel=1` 的用户（完全符合偏好）
2. 如果数量不足，自动放宽到 `matchLevel=2`
3. 依次降级，保证总能返回推荐结果

#### ✨ 优化效果
- ✅ 解决了"找不到匹配对象"的问题
- ✅ 优先推荐最匹配的用户
- ✅ 用户可以看到匹配质量
- ✅ 提升用户体验和匹配成功率

---

### 3. 新增：用户卡片统计数据字段

#### 🎯 优化目标
让用户在浏览推荐列表时能看到对方的社交活跃度，辅助决策。

#### 📌 涉及接口
以下所有返回用户卡片的接口都已新增统计数据：

| 接口 | 说明 |
|------|------|
| `GET /api/matching/recommend` | 获取推荐用户列表 |
| `GET /api/matching/liked-me` | 查看谁喜欢我 |
| `GET /api/matching/history` | 获取匹配历史 |
| `GET /api/follow/following` | 获取关注列表 |
| `GET /api/follow/followers` | 获取粉丝列表 |
| `GET /api/favorite/users` | 获取收藏用户列表 |

#### 📤 返回数据新增字段

在用户卡片对象中新增 4 个社交统计字段：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `followingCount` | Integer | 该用户关注了多少人 | `128` |
| `followersCount` | Integer | 该用户有多少粉丝 | `256` |
| `buddyMatchCount` | Integer | 搭子匹配成功数量 | `12` |
| `activityJoinCount` | Integer | 参与的活动数量 | `18` |

#### 📋 完整返回示例
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "userId": "U1699123456789AB12CD",
        "nickname": "小明",
        "avatar": "https://example.com/avatar.jpg",
        "age": 25,
        "gender": 1,
        "matchScore": 85.5,
        "matchLevel": 1,
        
        // ✨ 新增的社交统计数据
        "followingCount": 128,      // 关注数
        "followersCount": 256,      // 粉丝数
        "buddyMatchCount": 12,      // 搭子匹配数
        "activityJoinCount": 18,    // 活动参与数
        
        // 其他字段...
        "distance": 1500,
        "distanceText": "1.5km",
        "bio": "热爱生活，喜欢旅行",
        "interestTags": ["旅行", "阅读", "健身"]
      }
    ],
    "total": 50,
    "size": 10,
    "current": 1
  }
}
```

#### 🎨 前端展示建议

**用户卡片页面：**
```
┌─────────────────────────────────┐
│ 小明，25岁                       │
│ ⭐⭐⭐ 完全匹配                  │
│ 距离 1.5km · 匹配度 85.5分       │
│                                  │
│ 📊 社交活跃度                    │
│ ├─ 🔥 粉丝 256 · 关注 128       │
│ ├─ 💑 搭子匹配 12个              │
│ └─ 🎯 参与活动 18场              │
│                                  │
│ 🏷️ 旅行 · 阅读 · 健身          │
└─────────────────────────────────┘
```

**代码示例：**
```javascript
// 展示社交统计
const UserStats = ({ user }) => (
  <View className="stats">
    <Text>👥 粉丝 {user.followersCount}</Text>
    <Text>💑 匹配 {user.buddyMatchCount}个</Text>
    <Text>🎯 活动 {user.activityJoinCount}场</Text>
  </View>
);
```

#### 🎯 前端注意事项
- 统计数据都是实时查询，可能为 `0`
- 建议在列表页简化展示，详情页完整展示
- 可根据数值高低显示不同颜色或样式

#### ✨ 优化效果
- ✅ 用户卡片信息更丰富完整
- ✅ 可以判断对方社交活跃度
- ✅ 辅助用户做出更好的匹配决策
- ✅ 提升用户体验和信任度

---

## 2025-12-07 接口优化

### 4. 重构：评论系统支持多级树形结构

#### 🎯 优化目标
解决评论系统无法正确展示多级回复的问题，实现类似微博/朋友圈的评论树形结构。

#### ❌ 原有问题
1. **扁平化查询，无层级关系**
   - 所有评论混在一起按时间排序
   - 无法区分一级评论和回复
   
2. **缺少根评论引用**
   - A 评论动态 → B 回复 A → C 回复 B
   - C 的 `replyToCommentId` 指向 B，但不知道根评论是 A
   - 无法将所有回复归类到同一个一级评论下

3. **前端展示混乱**
   - 无法构建评论楼层
   - 回复关系不清晰

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `GET /api/comments/{momentId}` | 获取评论列表 |
| `POST /api/comments/{momentId}` | 发表评论 |
| `POST /api/comments/{momentId}/{commentId}/reply` | 回复评论 |

#### 📤 返回数据结构变化

**新增字段：**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `parentId` | Long | 父评论ID（一级评论为null） | `123` |
| `rootId` | Long | 根评论ID（一级评论指向自己） | `100` |
| `replyCount` | Integer | 回复数量（仅一级评论） | `5` |
| `replies` | List<CommentDTO> | 子评论列表（仅一级评论） | `[...]` |

**废弃字段：**
- `replyToCommentId` - 保留用于兼容，建议使用 `parentId` 替代

#### 📋 完整返回示例

**优化前（扁平结构）：** ❌
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "id": 1,
        "content": "这个活动很棒！",
        "replyToCommentId": null
      },
      {
        "id": 2,
        "content": "同意，我也想参加",
        "replyToCommentId": 1
      },
      {
        "id": 3,
        "content": "那我们一起吧",
        "replyToCommentId": 2
      }
    ]
  }
}
```
**问题：** 无法区分层级，前端需要自己组装树形结构

---

**优化后（树形结构）：** ✅
```json
{
  "code": 200,
  "data": {
    "records": [
      {
        "id": 1,
        "content": "这个活动很棒！",
        "parentId": null,
        "rootId": 1,
        "replyCount": 2,
        "replies": [
          {
            "id": 2,
            "content": "同意，我也想参加",
            "parentId": 1,
            "rootId": 1,
            "replyToUserId": "U123",
            "replyToNickname": "小明"
          },
          {
            "id": 3,
            "content": "那我们一起吧",
            "parentId": 2,
            "rootId": 1,
            "replyToUserId": "U456",
            "replyToNickname": "小红"
          }
        ]
      }
    ]
  }
}
```

#### 🎨 前端展示建议

**评论列表页面：**
```html
<!-- 一级评论 -->
<div class="comment-root">
  <div class="comment-content">这个活动很棒！</div>
  <div class="reply-count">共 2 条回复 ▼</div>
  
  <!-- 二级回复列表 -->
  <div class="replies">
    <div class="reply-item">
      <span class="reply-to">回复 @小明：</span>
      <span>同意，我也想参加</span>
    </div>
    <div class="reply-item">
      <span class="reply-to">回复 @小红：</span>
      <span>那我们一起吧</span>
    </div>
  </div>
</div>
```

**代码示例：**
```javascript
// 渲染评论树
const CommentTree = ({ comment }) => (
  <View className="comment-item">
    {/* 一级评论 */}
    <View className="comment-content">
      <Text>{comment.content}</Text>
    </View>
    
    {/* 回复列表 */}
    {comment.replies && comment.replies.length > 0 && (
      <View className="replies">
        <Text className="reply-count">
          共 {comment.replyCount} 条回复
        </Text>
        {comment.replies.map(reply => (
          <View key={reply.id} className="reply-item">
            {reply.replyToNickname && (
              <Text className="reply-to">
                回复 @{reply.replyToNickname}：
              </Text>
            )}
            <Text>{reply.content}</Text>
          </View>
        ))}
      </View>
    )}
  </View>
);
```

#### 🎯 前端注意事项

1. **分页逻辑变化**
   - 分页只对一级评论生效
   - 每个一级评论的所有回复会全部加载

2. **回复层级**
   - 一级评论：`parentId = null`, `rootId = id`
   - 二级回复：`parentId = 一级评论ID`, `rootId = 一级评论ID`
   - 三级回复：`parentId = 二级回复ID`, `rootId = 一级评论ID`

3. **兼容性**
   - `replyToCommentId` 字段已废弃但保留
   - 建议使用 `parentId` 和 `rootId`

#### 🔄 数据库变更

**新增字段：**
```sql
-- parent_id: 父评论ID
ALTER TABLE t_moment_comment ADD COLUMN parent_id BIGINT;

-- root_id: 根评论ID  
ALTER TABLE t_moment_comment ADD COLUMN root_id BIGINT;

-- 索引
ALTER TABLE t_moment_comment ADD INDEX idx_parent_id (parent_id);
ALTER TABLE t_moment_comment ADD INDEX idx_root_id (root_id);
```

**数据迁移：** 已自动迁移旧数据

#### ✨ 优化效果
- ✅ 评论支持多级树形结构
- ✅ 前端无需自己组装树形数据
- ✅ 一级评论分页，回复全部加载
- ✅ 回复关系更清晰直观
- ✅ 提升用户体验

#### ⚠️ 注意事项
- 运行前需要执行数据库迁移脚本
- 旧字段 `replyToCommentId` 保留兼容，新功能请使用 `parentId`

---

### 5. 新增：搭子匹配模式和设置字段

#### 🎯 优化目标
补充搭子匹配的专属设置字段，区分"恋爱交友"和"搭子匹配"两种不同的匹配模式。

#### ❌ 原有问题
1. **只有恋爱交友设置**
   - 只有年龄、身高、学历、收入等传统交友字段
   - 缺少搭子匹配的核心设置

2. **无法区分匹配模式**
   - 没有 `matchMode` 字段区分两种模式
   - 无法针对不同模式返回不同推荐策略

3. **缺少搭子核心字段**
   - 搭子类型（运动、旅行、美食等）
   - 活动时间偏好（工作日、周末、早晚）
   - 距离范围（5km、10km、20km、50km）

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `POST /api/matching/preference` | 设置匹配偏好 |
| `GET /api/matching/preference` | 获取匹配偏好 |
| `GET /api/matching/recommend` | 获取推荐用户列表 |

#### 📤 新增字段说明

**通用字段：**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `matchMode` | Integer | 匹配模式：1-恋爱交友，2-搭子匹配 | `2` |

**搭子匹配专用字段：**

| 字段名 | 类型 | 说明 | 可选值 | 示例 |
|--------|------|------|--------|------|
| `buddyTypes` | String | 搭子类型（多选） | 运动,学习,旅行,健身,爱好,美食,电影,音乐 | `"运动,旅行,美食"` |
| `activityTimes` | String | 活动时间（多选） | 工作日,周末,早上,下午,晚上 | `"周末,晚上"` |
| `distanceRange` | Integer | 距离范围(km) | 5, 10, 20, 50 | `20` |

#### 📋 请求示例

**恋爱交友模式：**
```json
{
  "matchMode": 1,
  "minAge": 25,
  "maxAge": 35,
  "minHeight": 165,
  "maxHeight": 180,
  "education": "本科,硕士",
  "incomeRange": "10-20万",
  "maxDistance": 10,
  "locationLatitude": 39.908823,
  "locationLongitude": 116.397470
}
```

**搭子匹配模式：**
```json
{
  "matchMode": 2,
  "buddyTypes": "运动,旅行,美食",
  "activityTimes": "周末,晚上",
  "distanceRange": 20,
  "locationLatitude": 39.908823,
  "locationLongitude": 116.397470
}
```

#### 📤 返回示例

```json
{
  "code": 200,
  "data": {
    "userId": "U1699123456789AB12CD",
    "matchMode": 2,
    
    // 搭子匹配设置
    "buddyTypes": "运动,旅行,美食",
    "activityTimes": "周末,晚上",
    "distanceRange": 20,
    
    // 位置信息（通用）
    "locationLatitude": 39.908823,
    "locationLongitude": 116.397470,
    
    // 恋爱交友设置（matchMode=1时返回）
    "minAge": null,
    "maxAge": null,
    "education": null
    // ...
  }
}
```

#### 🎨 前端展示建议

**搭子类型选择：**
```html
<view class="buddy-types">
  <view class="section-title">搭子类型</view>
  <view class="tags">
    <tag class="运动" />
    <tag class="学习" />
    <tag class="旅行" />
    <tag class="健身" />
    <tag class="爱好" />
    <tag class="美食" />
    <tag class="电影" />
    <tag class="音乐" />
  </view>
</view>
```

**活动时间选择：**
```html
<view class="activity-times">
  <view class="section-title">活动时间偏好</view>
  <view class="tags">
    <tag class="工作日" />
    <tag class="周末" />
    <tag class="早上" />
    <tag class="下午" />
    <tag class="晚上" />
  </view>
</view>
```

**距离范围选择：**
```html
<view class="distance-range">
  <view class="section-title">距离范围</view>
  <view class="options">
    <radio value="5">5km内</radio>
    <radio value="10">10km内</radio>
    <radio value="20">20km内</radio>
    <radio value="50">50km内</radio>
  </view>
</view>
```

#### 🎯 前端注意事项

1. **字段联动**
   - `matchMode = 1` 时，显示恋爱交友设置（年龄、身高等）
   - `matchMode = 2` 时，显示搭子匹配设置（类型、时间等）

2. **多选字段格式**
   - `buddyTypes` 和 `activityTimes` 用逗号分隔
   - 前端提交时拼接，展示时split

3. **距离字段区分**
   - 恋爱交友用 `maxDistance`
   - 搭子匹配用 `distanceRange`

#### 🔄 数据库变更

**新增字段：**
```sql
-- 匹配模式
ALTER TABLE t_matching_preference ADD COLUMN match_mode TINYINT DEFAULT 1;

-- 搭子类型偏好
ALTER TABLE t_matching_preference ADD COLUMN buddy_types VARCHAR(200);

-- 活动时间偏好
ALTER TABLE t_matching_preference ADD COLUMN activity_times VARCHAR(100);

-- 距离范围
ALTER TABLE t_matching_preference ADD COLUMN distance_range INT;
```

#### ✨ 优化效果
- ✅ 支持两种匹配模式切换
- ✅ 搭子匹配有专属设置字段
- ✅ 更符合搭子社交的产品定位
- ✅ 推荐算法可以针对不同模式优化

#### ⚠️ 注意事项
- 运行前需要执行数据库迁移脚本 `V1.2__add_buddy_matching_fields.sql`
- 默认 `matchMode = 1`（恋爱交友），需用户手动切换

---

### 6. 增强：用户资料接口返回数据

#### 🎯 优化目标
补充用户资料页的关键展示信息，包括相册预览、交互状态、最近动态和参与的活动。

#### ❌ 原有问题
1. **缺少相册预览**
   - 用户资料页无法直接看到照片
   - 需要额外调用相册接口

2. **缺少交互状态**
   - 不知道是否已关注该用户
   - 不知道是否已喜欢该用户

3. **缺少内容展示**
   - 看不到对方最近的动态
   - 看不到对方参与的活动

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `GET /api/profile/{userId}` | 查看他人资料 |
| `GET /api/profile/my` | 查看我的资料 |

#### 📤 新增字段说明

**1. 相册照片预览**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `photoAlbum` | List<String> | 相册照片（最多3张） | `["https://...jpg"]` |

**2. 交互状态**

| 字段名 | 类型 | 说明 | 值 |
|--------|------|------|-----|
| `isFollowing` | Integer | 是否关注了他 | 0-否，1-是 |
| `isLiked` | Integer | 是否喜欢了他 | 0-否，1-是 |

**3. 最近动态（recentMoments）**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | Long | 动态ID | `123` |
| `momentType` | Integer | 动态类型 | `1` |
| `content` | String | 内容 | `"今天天气不错"` |
| `coverImage` | String | 封面图 | `"https://...jpg"` |
| `likeCount` | Integer | 点赞数 | `10` |
| `commentCount` | Integer | 评论数 | `5` |
| `createdAt` | LocalDateTime | 创建时间 | `"2025-12-06T10:30:00"` |

**4. 参与的活动（participatedActivities）**

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | Long | 活动ID | `456` |
| `title` | String | 活动标题 | `"周末爬山活动"` |
| `coverImage` | String | 活动封面 | `"https://...jpg"` |
| `activityTime` | LocalDateTime | 活动时间 | `"2025-12-10T09:00:00"` |
| `registrationCount` | Integer | 报名人数 | `20` |
| `status` | Integer | 活动状态 | `1` |

#### 📋 完整返回示例

```json
{
  "code": 200,
  "data": {
    "userId": "U1699123456789AB12CD",
    "nickname": "张三",
    "avatar": "https://example.com/avatar.jpg",
    "age": 25,
    "gender": 1,
    "bio": "热爱生活，喜欢旅行",
    
    // ✨ 新增：相册预览（最多3张）
    "photoAlbum": [
      "https://example.com/photo1.jpg",
      "https://example.com/photo2.jpg",
      "https://example.com/photo3.jpg"
    ],
    
    // ✨ 新增：交互状态
    "isFollowing": 1,  // 已关注
    "isLiked": 1,      // 已喜欢
    
    // ✨ 新增：最近动态（最多3条）
    "recentMoments": [
      {
        "id": 123,
        "momentType": 1,
        "content": "今天天气不错",
        "coverImage": "https://example.com/moment.jpg",
        "likeCount": 10,
        "commentCount": 5,
        "createdAt": "2025-12-06T10:30:00"
      },
      {
        "id": 124,
        "momentType": 3,
        "content": "周末爬山约起来",
        "coverImage": "https://example.com/moment2.jpg",
        "likeCount": 15,
        "commentCount": 8,
        "createdAt": "2025-12-05T14:20:00"
      }
    ],
    
    // ✨ 新增：参与的活动（最多3个）
    "participatedActivities": [
      {
        "id": 456,
        "title": "周末爬山活动",
        "coverImage": "https://example.com/activity.jpg",
        "activityTime": "2025-12-10T09:00:00",
        "registrationCount": 20,
        "status": 1
      },
      {
        "id": 457,
        "title": "羽毛球友谊赛",
        "coverImage": "https://example.com/activity2.jpg",
        "activityTime": "2025-12-15T15:00:00",
        "registrationCount": 12,
        "status": 1
      }
    ],
    
    // 原有字段
    "tags": ["旅行", "美食", "运动"],
    "vipLevel": 1,
    "onlineStatus": 1,
    "height": 175,
    "occupation": "互联网",
    "education": "本科",
    "city": "北京"
  }
}
```

#### 🎨 前端展示建议

**用户资料页面布局：**
```html
<view class="profile-page">
  <!-- 1. 顶部基本信息 -->
  <view class="profile-header">
    <image class="avatar" :src="avatar" />
    <text class="nickname">{{ nickname }}</text>
    <text class="bio">{{ bio }}</text>
  </view>
  
  <!-- 2. 互动按钮 -->
  <view class="action-buttons">
    <button :class="{active: isFollowing}" @click="toggleFollow">
      <icon type="follow" />
      {{ isFollowing ? '已关注' : '关注TA' }}
    </button>
    <button :class="{active: isLiked}" @click="toggleLike">
      <icon type="heart" />
      {{ isLiked ? '已喜欢' : '喜欢' }}
    </button>
    <button @click="startChat">
      <icon type="chat" />
      聊天
    </button>
  </view>
  
  <!-- 3. 相册预览 -->
  <view class="photo-album-section">
    <view class="section-title">
      TA的相册
      <text class="more" @click="viewFullAlbum">查看更多 ></text>
    </view>
    <view class="photo-grid">
      <image 
        v-for="(photo, index) in photoAlbum" 
        :key="index"
        :src="photo"
        @click="previewPhotos(index)"
      />
      <!-- 如果有更多照片，显示"+N"提示 -->
      <view v-if="hasMorePhotos" class="more-indicator">
        +{{ totalPhotoCount - 3 }}
      </view>
    </view>
  </view>
  
  <!-- 4. 最近动态 -->
  <view class="moments-section">
    <view class="section-title">
      TA的动态
      <text class="more" @click="viewAllMoments">查看全部 ></text>
    </view>
    <view class="moment-list">
      <moment-card 
        v-for="moment in recentMoments" 
        :key="moment.id"
        :data="moment"
        mode="simple"
      />
    </view>
  </view>
  
  <!-- 5. 参与的活动 -->
  <view class="activities-section">
    <view class="section-title">
      TA参与的活动
      <text class="more" @click="viewAllActivities">查看全部 ></text>
    </view>
    <view class="activity-list">
      <activity-card 
        v-for="activity in participatedActivities" 
        :key="activity.id"
        :data="activity"
        mode="compact"
      />
    </view>
  </view>
  
  <!-- 6. 标签和其他信息 -->
  <view class="tags-section">
    <tag v-for="tag in tags" :key="tag">{{ tag }}</tag>
  </view>
</view>
```

**代码示例：**
```javascript
// 用户资料页面
export default {
  data() {
    return {
      profile: null
    }
  },
  
  computed: {
    hasMorePhotos() {
      return this.profile?.photoAlbum?.length >= 3;
    }
  },
  
  methods: {
    // 加载用户资料
    async loadProfile(userId) {
      const res = await api.get(`/profile/${userId}`);
      this.profile = res.data;
    },
    
    // 预览照片
    previewPhotos(index) {
      wx.previewImage({
        current: this.profile.photoAlbum[index],
        urls: this.profile.photoAlbum
      });
    },
    
    // 查看完整相册
    async viewFullAlbum() {
      // 调用完整相册接口
      const res = await api.get('/media/list', {
        params: { mediaType: 'album', userId: this.profile.userId }
      });
      // 展示完整相册
    },
    
    // 切换关注状态
    async toggleFollow() {
      if (this.profile.isFollowing) {
        await api.post(`/follow/unfollow/${this.profile.userId}`);
        this.profile.isFollowing = 0;
      } else {
        await api.post(`/follow/${this.profile.userId}`);
        this.profile.isFollowing = 1;
      }
    },
    
    // 切换喜欢状态
    async toggleLike() {
      if (this.profile.isLiked) {
        // 取消喜欢的逻辑
      } else {
        await api.post(`/matching/like/${this.profile.userId}`);
        this.profile.isLiked = 1;
      }
    }
  }
}
```

#### 🎯 前端注意事项

1. **字段判断**
   - `photoAlbum`、`recentMoments`、`participatedActivities` 可能为空数组
   - 展示前需要判断数组长度

2. **交互状态**
   - 查看自己的资料时，`isFollowing` 和 `isLiked` 都为 0
   - 不应该显示关注和喜欢按钮

3. **数量限制**
   - 相册最多3张，需要"查看更多"按钮
   - 动态最多3条，需要"查看全部"链接
   - 活动最多3个，需要"查看全部"链接

4. **点击事件**
   - 点击动态卡片 → 跳转到动态详情页
   - 点击活动卡片 → 跳转到活动详情页
   - 点击相册照片 → 预览大图

#### ✨ 优化效果
- ✅ 用户资料页信息完整丰富
- ✅ 一次请求获取所有必要信息，减少接口调用
- ✅ 清晰展示交互状态（关注/喜欢）
- ✅ 直观展示用户活跃度（动态/活动）
- ✅ 提升用户体验和信息展示效率

#### ⚠️ 注意事项
- 动态和活动查询已自动过滤（审核通过、未删除）
- 相册照片来自 `t_user_profile.photo_album` 字段
- 活动封面来自 `t_moment_photo` 表的第一张图片

---

## 2025-12-08 接口优化

### 7. 新增：取消喜欢接口

#### 🎯 优化目标
补充取消喜欢功能，允许用户撤销之前的喜欢操作，提升用户体验。

#### ❌ 原有问题
1. **缺少取消喜欢功能**
   - 用户误操作喜欢后无法撤销
   - 在"谁喜欢我"列表中无法移除不感兴趣的用户
   - 已匹配的用户无法取消匹配

2. **业务场景缺失**
   - 用户改变心意想取消喜欢
   - 清理"谁喜欢我"列表中的不感兴趣用户

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `DELETE /api/matching/like` | 取消喜欢操作 |

#### 📥 请求参数

**请求方式：** `DELETE`  
**Content-Type：** `application/json`

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| toUserId | String | 是 | 要取消喜欢的用户业务ID | `"U1735123456789ABCDEF"` |

#### 📋 请求示例

```bash
curl -X DELETE "http://localhost:8080/api/matching/like" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "toUserId": "U1735123456789ABCDEF"
  }'
```

**请求Body：**
```json
{
  "toUserId": "U1735123456789ABCDEF"
}
```

#### 📤 响应示例

```json
{
  "code": 200,
  "message": "取消喜欢成功",
  "data": "取消喜欢成功"
}
```

#### 🔄 业务逻辑说明

1. **取消单向喜欢**
   - 如果只是单向喜欢（对方未回应），直接删除喜欢记录
   - 对方在"谁喜欢我"列表中不再看到你

2. **取消双向匹配**
   - 如果已经匹配成功（双向喜欢），取消后：
     - 删除你的喜欢记录
     - 将对方的记录改为单向喜欢（`matchResult = 1`）
     - 对方仍能看到你，但匹配状态降级为单向

3. **限制说明**
   - 只能取消"喜欢"和"超级喜欢"类型的记录
   - 不能取消"跳过"记录（跳过本身就是拒绝）

#### 🎨 前端展示建议

**用户资料页面：**
```javascript
// 取消喜欢按钮
<button 
  v-if="isLiked" 
  @click="cancelLike"
  class="btn-cancel-like"
>
  取消喜欢
</button>

// 取消喜欢方法
async cancelLike() {
  try {
    await api.delete('/matching/like', {
      data: { toUserId: this.profile.userId }
    });
    this.isLiked = false;
    this.showToast('已取消喜欢');
  } catch (error) {
    this.showToast('取消失败，请重试');
  }
}
```

**"谁喜欢我"列表：**
```javascript
// 在列表中显示"移除"按钮
<UserCard 
  v-for="user in likedMeList"
  :key="user.userId"
  :user="user"
>
  <button @click="removeFromLikedMe(user.userId)">
    移除
  </button>
</UserCard>

// 移除方法（调用取消喜欢接口）
async removeFromLikedMe(userId) {
  // 注意：这里需要调用对方的视角，即对方取消喜欢我
  // 实际业务中可能需要单独的接口，或者通过"取消喜欢"接口实现
  await api.delete('/matching/like', {
    data: { toUserId: userId }
  });
}
```

#### 🎯 前端注意事项

1. **接口调用方向**
   - 取消喜欢：我取消喜欢对方 → `DELETE /api/matching/like`，`toUserId` 是对方
   - 从"谁喜欢我"移除：需要对方取消喜欢我，但当前接口不支持，建议新增接口或调整逻辑

2. **状态更新**
   - 取消喜欢后，需要更新本地状态 `isLiked = false`
   - 如果已匹配，需要更新匹配状态

3. **错误处理**
   - 如果记录不存在，返回 40004 错误
   - 需要提示用户操作失败

#### ✨ 优化效果
- ✅ 用户可以撤销误操作
- ✅ 支持取消已匹配的用户
- ✅ 提升用户体验和操作灵活性
- ✅ 完善匹配功能的闭环

---

### 8. 新增：移除粉丝接口

#### 🎯 优化目标
补充移除粉丝功能，允许用户主动移除不想要的粉丝，保护用户隐私和社交环境。

#### ❌ 原有问题
1. **缺少移除粉丝功能**
   - 用户无法主动移除粉丝
   - 遇到骚扰或不想被关注时无法处理
   - 粉丝列表管理功能不完整

2. **隐私保护缺失**
   - 无法控制谁可以关注我
   - 无法清理粉丝列表

#### 📌 涉及接口
| 接口 | 说明 |
|------|------|
| `DELETE /api/user/followers/{followerId}` | 移除粉丝 |

#### 📥 请求参数

**请求方式：** `DELETE`  
**路径参数：**

| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| followerId | String | 是 | 要移除的粉丝用户业务ID | `"U1735123456789ABCDEF"` |

#### 📋 请求示例

```bash
curl -X DELETE "http://localhost:8080/api/user/followers/U1735123456789ABCDEF" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

#### 📤 响应示例

```json
{
  "code": 200,
  "message": "移除粉丝成功",
  "data": "移除粉丝成功"
}
```

#### 🔄 业务逻辑说明

1. **移除操作**
   - 删除对方关注我的记录（`followerId` 关注 `userId`）
   - 使用软删除，记录保留但不再显示

2. **验证逻辑**
   - 验证该用户确实是你的粉丝
   - 不能移除自己
   - 用户不存在时返回错误

3. **影响范围**
   - 对方不再出现在你的粉丝列表中
   - 对方无法再看到你的动态（如果设置了隐私）
   - 对方无法再给你发消息（如果设置了隐私）

#### 🎨 前端展示建议

**粉丝列表页面：**
```javascript
// 粉丝列表项
<UserCard 
  v-for="follower in followersList"
  :key="follower.userId"
  :user="follower"
>
  <button 
    @click="removeFollower(follower.userId)"
    class="btn-remove"
  >
    移除粉丝
  </button>
</UserCard>

// 移除粉丝方法
async removeFollower(followerId) {
  try {
    await api.delete(`/user/followers/${followerId}`);
    this.showToast('已移除粉丝');
    // 刷新列表
    this.loadFollowers();
  } catch (error) {
    if (error.code === 40004) {
      this.showToast('该用户不是你的粉丝');
    } else {
      this.showToast('移除失败，请重试');
    }
  }
}
```

**用户资料页面（查看他人）：**
```javascript
// 如果是我的粉丝，显示"移除粉丝"按钮
<button 
  v-if="isMyFollower"
  @click="removeFollower"
  class="btn-remove-follower"
>
  移除粉丝
</button>
```

#### 🎯 前端注意事项

1. **权限判断**
   - 只有查看自己的粉丝列表时才能移除
   - 查看他人资料时，如果对方是我的粉丝，也可以移除

2. **确认提示**
   - 建议添加确认对话框，避免误操作
   ```javascript
   async removeFollower(followerId) {
     const confirmed = await this.showConfirm('确定要移除该粉丝吗？');
     if (!confirmed) return;
     // 执行移除操作
   }
   ```

3. **列表刷新**
   - 移除成功后需要刷新粉丝列表
   - 或者从列表中移除该项

4. **错误处理**
   - 40001：不能移除自己
   - 40004：该用户不是你的粉丝
   - 404：用户不存在

#### ✨ 优化效果
- ✅ 用户可以主动管理粉丝列表
- ✅ 保护用户隐私和社交环境
- ✅ 完善关注功能的闭环
- ✅ 提升用户体验和安全感

---

## 📌 待优化项

### 性能优化
- [ ] 用户卡片社交统计数据添加 Redis 缓存
- [ ] 匹配推荐结果缓存优化
- [ ] 数据库查询索引优化

### 功能完善
- [ ] 关注/粉丝功能实现（目前返回0）
- [ ] 收藏功能完善
- [ ] 用户反馈系统

### 体验优化
- [ ] 匹配推荐算法权重调优
- [ ] 个性化推荐增强
- [ ] 消息推送优化

---

## 🔖 版本记录

| 版本 | 日期 | 优化项数量 | 主要内容 |
|------|------|-----------|----------|
| v1.0 | 2025-12-06 | 3 | 时间格式修复、分级降级策略、社交统计数据 |
| v1.1 | 2025-12-07 | 3 | 评论系统树形结构、搭子匹配模式、用户资料增强 |
| v1.2 | 2025-12-08 | 2 | 取消喜欢接口、移除粉丝接口 |

---

## 📝 接口优化记录规范

### 记录格式

每个优化项应包含以下内容（**按接口视角**）：

#### 必填项
1. **🎯 优化目标/问题描述**：说明为什么要优化
2. **📌 涉及接口**：列出所有受影响的 API 接口（方法 + URL）
3. **📥 请求参数变化**（如有）：新增/修改/删除的参数
4. **📤 返回数据变化**（如有）：新增/修改的字段
5. **✨ 优化效果**：对前端的影响和收益

#### 可选项
6. **⚠️ 前端注意事项**：需要前端配合修改的地方
7. **🎨 前端展示建议**：UI/UX 建议
8. **📋 完整示例**：请求/响应完整 JSON 示例

### 提交流程

```
1. 后端完成优化
   ↓
2. 立即记录到本文档（在对应日期下）
   ↓
3. 更新文档顶部"最后更新"时间
   ↓
4. 通知前端查看优化记录
   ↓
5. 前端根据记录调整代码
```

### 命名规范

- **修复类**：修复：XXX 接口问题
- **优化类**：优化：XXX 接口功能增强
- **新增类**：新增：XXX 字段/功能

### 示例模板

```markdown
### X. 优化：XXX接口功能增强

#### 🎯 优化目标
简要说明优化原因

#### 📌 涉及接口
- **GET** `/api/xxx/xxx`
- **POST** `/api/xxx/xxx`

#### 📥 请求参数变化
| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| xxx | String | 是 | xxx | "xxx" |

#### 📤 返回数据新增字段
| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| xxx | Integer | xxx | 123 |

#### 🎯 前端注意事项
- 注意事项1
- 注意事项2

#### ✨ 优化效果
- ✅ 效果1
- ✅ 效果2
```

---

## 📞 联系方式

**问题反馈：**
- 前端发现接口问题 → 联系后端开发
- 后端优化接口 → 在本文档记录并通知前端

**文档维护：** 后端开发团队  
**查看方式：** `friends-ui/docs/系统优化记录.md`
